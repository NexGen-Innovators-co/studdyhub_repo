[
  {
    "function_name": "_social_chat_message_reads_propagate",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  -- Only update if the message exists and the reader is not the sender\n  UPDATE public.social_chat_messages\n  SET\n    is_read = TRUE,\n    read_at = GREATEST(COALESCE(read_at, 'epoch'::timestamptz), NEW.read_at)\n  WHERE id = NEW.message_id\n    AND (sender_id IS DISTINCT FROM NEW.user_id);\n\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "_social_group_members_propagate",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    PERFORM public._social_groups_recalc_members_count_for(NEW.group_id);\n    RETURN NEW;\n  ELSIF TG_OP = 'DELETE' THEN\n    PERFORM public._social_groups_recalc_members_count_for(OLD.group_id);\n    RETURN OLD;\n  ELSIF TG_OP = 'UPDATE' THEN\n    -- If group_id changed, recalc both\n    IF OLD.group_id IS DISTINCT FROM NEW.group_id THEN\n      PERFORM public._social_groups_recalc_members_count_for(OLD.group_id);\n      PERFORM public._social_groups_recalc_members_count_for(NEW.group_id);\n    ELSIF OLD.status IS DISTINCT FROM NEW.status THEN\n      -- status changed for same group\n      PERFORM public._social_groups_recalc_members_count_for(NEW.group_id);\n    END IF;\n    RETURN NEW;\n  END IF;\n\n  RETURN NULL;\nEND;\n"
  },
  {
    "function_name": "_social_groups_recalc_members_count_for",
    "arguments": "p_group_id uuid",
    "return_type": "void",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\n  UPDATE public.social_groups g\n  SET members_count = COALESCE(sub.cnt, 0)\n  FROM (\n    SELECT COUNT(*) AS cnt\n    FROM public.social_group_members\n    WHERE status = 'active' AND group_id = p_group_id\n  ) AS sub\n  WHERE g.id = p_group_id;\n"
  },
  {
    "function_name": "apply_code_night_promo",
    "arguments": "p_user_id uuid, p_promo_code text",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  -- Security check: Ensure the user is applying it to their own account\r\n  IF auth.uid() <> p_user_id THEN\r\n    RAISE EXCEPTION 'Not authorized';\r\n  END IF;\r\n\r\n  -- Validate Promo Code Server-Side\r\n  IF UPPER(TRIM(p_promo_code)) <> 'CODENIGHT2026' THEN\r\n    RAISE EXCEPTION 'Invalid promo code';\r\n  END IF;\r\n\r\n  -- Insert or update the subscription for the user\r\n  INSERT INTO subscriptions (user_id, plan_type, status, current_period_end)\r\n  VALUES (p_user_id, 'genius', 'active', NOW() + INTERVAL '1 month')\r\n  ON CONFLICT (user_id)\r\n  DO UPDATE SET\r\n    plan_type = 'genius',\r\n    status = 'active',\r\n    -- Extend current period if already valid, or set to 1 month from now\r\n    current_period_end = GREATEST(COALESCE(subscriptions.current_period_end, NOW()), NOW() + INTERVAL '1 month');\r\nEND;\r\n"
  },
  {
    "function_name": "approve_group_member",
    "arguments": "p_membership_id uuid, p_group_id uuid, p_user_id uuid, p_approver_id uuid",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_result JSONB;\r\n  v_group_name TEXT;\r\n  v_member_username TEXT;\r\nBEGIN\r\n  -- Check if approver is admin/moderator of the group\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM social_group_members \r\n    WHERE group_id = p_group_id \r\n    AND user_id = p_approver_id \r\n    AND role IN ('admin', 'moderator')\r\n    AND status = 'active'\r\n  ) THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', 'Not authorized to approve members'\r\n    );\r\n  END IF;\r\n\r\n  -- Update the membership status\r\n  UPDATE social_group_members \r\n  SET status = 'active'\r\n  WHERE id = p_membership_id\r\n    AND group_id = p_group_id\r\n    AND user_id = p_user_id\r\n    AND status = 'pending';\r\n\r\n  -- Check if update succeeded\r\n  IF NOT FOUND THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', 'Membership not found or not pending'\r\n    );\r\n  END IF;\r\n\r\n  -- Get group name for notification\r\n  SELECT name INTO v_group_name \r\n  FROM social_groups \r\n  WHERE id = p_group_id;\r\n\r\n  -- Get member username for notification\r\n  SELECT username INTO v_member_username \r\n  FROM social_users \r\n  WHERE id = p_user_id;\r\n\r\n  -- Send notification\r\n  INSERT INTO social_notifications (\r\n    user_id, type, title, message, data\r\n  ) VALUES (\r\n    p_user_id,\r\n    'group_invite',\r\n    'Request Approved',\r\n    'Your request to join \"' || v_group_name || '\" has been approved!',\r\n    jsonb_build_object('group_id', p_group_id)\r\n  );\r\n\r\n  RETURN jsonb_build_object(\r\n    'success', true,\r\n    'message', 'Member approved successfully'\r\n  );\r\nEND;\r\n"
  },
  {
    "function_name": "assign_referral_code",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  new_code TEXT;\r\n  code_exists BOOLEAN;\r\nBEGIN\r\n  -- Only assign if referral_code is NULL\r\n  IF NEW.referral_code IS NULL THEN\r\n    LOOP\r\n      -- Generate a random 8-character code\r\n      new_code := UPPER(SUBSTR(MD5(RANDOM()::TEXT), 1, 8));\r\n      \r\n      -- Check if this code already exists (use table qualification to avoid ambiguity)\r\n      SELECT EXISTS (\r\n        SELECT 1 \r\n        FROM public.profiles p \r\n        WHERE p.referral_code = new_code\r\n      ) INTO code_exists;\r\n      \r\n      -- Exit loop if code is unique\r\n      EXIT WHEN NOT code_exists;\r\n    END LOOP;\r\n    \r\n    NEW.referral_code := new_code;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "build_where_clause",
    "arguments": "conditions jsonb",
    "return_type": "text",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_where_parts text[];\r\n  v_condition jsonb;\r\n  v_column text;\r\n  v_operator text;\r\n  v_value text;\r\n  v_part text;\r\nBEGIN\r\n  FOR v_condition IN SELECT * FROM jsonb_array_elements(conditions)\r\n  LOOP\r\n    v_column := v_condition->>'column';\r\n    v_operator := v_condition->>'operator';\r\n    v_value := v_condition->>'value';\r\n    \r\n    CASE v_operator\r\n      WHEN 'eq' THEN v_part := format('%I = %L', v_column, v_value);\r\n      WHEN 'neq' THEN v_part := format('%I != %L', v_column, v_value);\r\n      WHEN 'gt' THEN v_part := format('%I > %L', v_column, v_value);\r\n      WHEN 'gte' THEN v_part := format('%I >= %L', v_column, v_value);\r\n      WHEN 'lt' THEN v_part := format('%I < %L', v_column, v_value);\r\n      WHEN 'lte' THEN v_part := format('%I <= %L', v_column, v_value);\r\n      WHEN 'like' THEN v_part := format('%I LIKE %L', v_column, v_value);\r\n      WHEN 'ilike' THEN v_part := format('%I ILIKE %L', v_column, v_value);\r\n      WHEN 'in' THEN v_part := format('%I = ANY(%L::text[])', v_column, v_value);\r\n      WHEN 'is' THEN v_part := format('%I IS %s', v_column, CASE WHEN v_value = 'null' THEN 'NULL' ELSE v_value END);\r\n      ELSE v_part := format('%I = %L', v_column, v_value);\r\n    END CASE;\r\n    \r\n    v_where_parts := array_append(v_where_parts, v_part);\r\n  END LOOP;\r\n  \r\n  RETURN array_to_string(v_where_parts, ' AND ');\r\nEND;\r\n"
  },
  {
    "function_name": "check_podcast_permissions",
    "arguments": "p_podcast_id uuid, p_user_id uuid",
    "return_type": "TABLE(is_host boolean, is_cohost boolean, can_speak boolean, can_moderate boolean)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_podcast ai_podcasts%ROWTYPE;\r\n  v_cohost podcast_cohosts%ROWTYPE;\r\nBEGIN\r\n  -- Get podcast info\r\n  SELECT * INTO v_podcast \r\n  FROM ai_podcasts \r\n  WHERE id = p_podcast_id;\r\n  \r\n  -- Check if user is the podcast creator\r\n  IF v_podcast.user_id = p_user_id THEN\r\n    RETURN QUERY SELECT true, false, true, true;\r\n    RETURN;\r\n  END IF;\r\n  \r\n  -- Check if user is a co-host\r\n  SELECT * INTO v_cohost\r\n  FROM podcast_cohosts\r\n  WHERE podcast_id = p_podcast_id\r\n    AND user_id = p_user_id\r\n    AND is_active = true;\r\n  \r\n  IF FOUND THEN\r\n    RETURN QUERY SELECT \r\n      false,\r\n      true,\r\n      'speak' = ANY(v_cohost.permissions),\r\n      'moderate' = ANY(v_cohost.permissions);\r\n    RETURN;\r\n  END IF;\r\n  \r\n  -- Default: regular listener\r\n  RETURN QUERY SELECT false, false, false, false;\r\nEND;\r\n"
  },
  {
    "function_name": "check_user_is_cohost",
    "arguments": "p_podcast_id uuid, p_user_id uuid",
    "return_type": "boolean",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\n  SELECT EXISTS (\n    SELECT 1 FROM public.podcast_members\n    WHERE podcast_id = p_podcast_id\n      AND user_id = p_user_id\n      AND role = 'co-host'\n  );\n"
  },
  {
    "function_name": "cleanup_old_notifications",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  DELETE FROM notifications\r\n  WHERE created_at < NOW() - INTERVAL '30 days'\r\n  AND read = TRUE;\r\n  \r\n  DELETE FROM notifications\r\n  WHERE expires_at IS NOT NULL\r\n  AND expires_at < NOW();\r\nEND;\r\n"
  },
  {
    "function_name": "cleanup_old_podcast_chunks",
    "arguments": "retention_days integer",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  DELETE FROM podcast_chunks WHERE created_at < now() - (retention_days || ' days')::interval;\r\nEND;\r\n"
  },
  {
    "function_name": "cleanup_podcast_cohosts",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  IF NEW.is_live = false AND OLD.is_live = true THEN\r\n    DELETE FROM podcast_cohosts WHERE podcast_id = NEW.id;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "create_social_user_profile",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  -- Skip creation until the email is verified\n  IF NEW.email_confirmed_at IS NULL THEN\n    RETURN NULL;  -- No social user entry yet\n  END IF;\n\n  INSERT INTO public.social_users (id, username, display_name)\n  VALUES (\n    NEW.id,\n    CONCAT('user_', substr(md5(random()::text), 0, 8)),\n    CONCAT('User ', substr(md5(random()::text), 0, 8))\n  );\n\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "expire_old_podcast_invites",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE public.podcast_invites\r\n  SET status = 'expired'\r\n  WHERE status = 'pending'\r\n  AND expires_at < NOW();\r\nEND;\r\n"
  },
  {
    "function_name": "generate_referral_code",
    "arguments": "",
    "return_type": "text",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n  result TEXT := '';\n  i INTEGER;\nBEGIN\n  FOR i IN 1..6 LOOP\n    result := result || substr(chars, floor(random() * length(chars) + 1)::integer, 1);\n  END LOOP;\n  RETURN result;\nEND;\n"
  },
  {
    "function_name": "generate_unique_username",
    "arguments": "p_email text",
    "return_type": "text",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    base     text := regexp_replace(split_part(p_email, '@', 1), '[^a-zA-Z0-9]', '_', 'g');\n    suffix   int  := 0;\n    candidate text;\nBEGIN\n    LOOP\n        candidate := base || CASE WHEN suffix = 0 THEN '' ELSE '_' || suffix::text END;\n\n        -- If the candidate is not already taken, exit the loop\n        PERFORM 1 FROM public.social_users WHERE username = candidate;\n        EXIT WHEN NOT FOUND;\n\n        suffix := suffix + 1;\n    END LOOP;\n\n    RETURN candidate;\nEND;\n"
  },
  {
    "function_name": "get_due_flashcards",
    "arguments": "p_user_id uuid, p_limit integer",
    "return_type": "TABLE(id uuid, front text, back text, category text, difficulty text, hint text, review_count integer, ease_factor numeric)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        f.id,\n        f.front,\n        f.back,\n        f.category,\n        f.difficulty,\n        f.hint,\n        f.review_count,\n        f.ease_factor\n    FROM public.flashcards f\n    WHERE f.user_id = p_user_id\n    AND (f.next_review_at IS NULL OR f.next_review_at <= NOW())\n    ORDER BY f.next_review_at NULLS FIRST, f.created_at\n    LIMIT p_limit;\nEND;\n"
  },
  {
    "function_name": "get_learning_velocity",
    "arguments": "p_user_id uuid, p_weeks integer",
    "return_type": "TABLE(week text, items bigint)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH weeks AS (\r\n    SELECT generate_series(\r\n      CURRENT_DATE - (p_weeks * 7 - 1), \r\n      CURRENT_DATE, \r\n      '1 week'::interval\r\n    )::date as week_start\r\n  )\r\n  SELECT \r\n    'W' || row_number() OVER (ORDER BY weeks.week_start) as week,\r\n    COUNT(n.id) as items\r\n  FROM weeks\r\n  LEFT JOIN notes n ON n.user_id = p_user_id \r\n    AND n.created_at >= weeks.week_start \r\n    AND n.created_at < weeks.week_start + '7 days'::interval\r\n  GROUP BY weeks.week_start\r\n  ORDER BY weeks.week_start;\r\nEND;\r\n"
  },
  {
    "function_name": "get_or_create_group_chat_session",
    "arguments": "p_group_id uuid",
    "return_type": "uuid",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_session_id UUID;\r\nBEGIN\r\n  -- Try to find existing session\r\n  SELECT id INTO v_session_id\r\n  FROM social_chat_sessions\r\n  WHERE chat_type = 'group' AND group_id = p_group_id\r\n  LIMIT 1;\r\n  \r\n  -- Create if doesn't exist\r\n  IF v_session_id IS NULL THEN\r\n    INSERT INTO social_chat_sessions (chat_type, group_id)\r\n    VALUES ('group', p_group_id)\r\n    RETURNING id INTO v_session_id;\r\n  END IF;\r\n  \r\n  RETURN v_session_id;\r\nEND;\r\n"
  },
  {
    "function_name": "get_schema_tables",
    "arguments": "",
    "return_type": "TABLE(table_name text, table_type text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    table_name::text,\r\n    table_type::text\r\n  FROM information_schema.tables\r\n  WHERE table_schema = 'public'\r\n    AND table_type = 'BASE TABLE'\r\n  ORDER BY table_name;\r\n"
  },
  {
    "function_name": "get_session_unread_count",
    "arguments": "p_session_id uuid, p_user_id uuid",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT COUNT(*)::INTEGER\r\n        FROM social_chat_messages\r\n        WHERE session_id = p_session_id\r\n        AND sender_id != p_user_id\r\n        AND is_read = FALSE\r\n    );\r\nEND;\r\n"
  },
  {
    "function_name": "get_suggested_users",
    "arguments": "p_user_id uuid, p_exclude_ids uuid[], p_limit integer, p_offset integer",
    "return_type": "TABLE(id uuid, username text, display_name text, avatar_url text, bio text, interests text[], followers_count integer, following_count integer, posts_count integer, is_verified boolean, last_active timestamp with time zone, created_at timestamp with time zone, recommendation_score numeric)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\ndeclare\r\n  thirty_days_ago timestamptz := now() - interval '30 days';\r\n  v_user_interests text[] := '{}';\r\nbegin\r\n  select coalesce(su2.interests, '{}') into v_user_interests\r\n  from social_users su2\r\n  where su2.id = p_user_id;\r\n\r\n  return query\r\n  select\r\n    su.id,\r\n    su.username,\r\n    su.display_name,\r\n    su.avatar_url,\r\n    su.bio,\r\n    su.interests,\r\n    su.followers_count,\r\n    su.following_count,\r\n    su.posts_count,\r\n    su.is_verified,\r\n    su.last_active,\r\n    su.created_at,\r\n\r\n    (\r\n      -- common interests (10 pts each)\r\n      (select coalesce(sum(1),0)\r\n       from unnest(coalesce(su.interests, '{}')) as i\r\n       where i = any(v_user_interests)\r\n      ) * 10\r\n\r\n      -- recent activity (5 pts)\r\n      + (case when su.last_active > thirty_days_ago then 5 else 0 end)\r\n\r\n      -- follower bonus (max 5 pts)\r\n      + least(coalesce(su.followers_count,0) / 100.0, 5)\r\n\r\n      -- post bonus (max 3 pts)\r\n      + least(coalesce(su.posts_count,0) / 10.0, 3)\r\n\r\n      -- profile completeness (max 3 pts)\r\n      + (case when su.avatar_url is not null then 1 else 0 end)\r\n      + (case when su.bio is not null and su.bio <> 'New to the community!' then 1 else 0 end)\r\n      + (case when coalesce(array_length(su.interests,1),0) > 0 then 1 else 0 end)\r\n\r\n      -- verified bonus (2 pts)\r\n      + (case when su.is_verified then 2 else 0 end)\r\n    )::numeric as recommendation_score\r\n\r\n  from social_users su\r\n  where su.id <> ALL(p_exclude_ids)\r\n  order by recommendation_score desc\r\n  limit p_limit\r\n  offset p_offset;\r\nend;\r\n"
  },
  {
    "function_name": "get_table_columns",
    "arguments": "table_name text",
    "return_type": "TABLE(name text, type text, nullable boolean, is_primary_key boolean, is_foreign_key boolean, default_value text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    c.column_name::text AS name,\r\n    c.data_type::text AS type,\r\n    (c.is_nullable = 'YES')::boolean AS nullable,\r\n    (EXISTS (\r\n      SELECT 1 FROM information_schema.key_column_usage kcu\r\n      JOIN information_schema.table_constraints tc \r\n        ON kcu.constraint_name = tc.constraint_name\r\n      WHERE tc.constraint_type = 'PRIMARY KEY'\r\n        AND kcu.table_name = c.table_name\r\n        AND kcu.column_name = c.column_name\r\n    ))::boolean AS is_primary_key,\r\n    (EXISTS (\r\n      SELECT 1 FROM information_schema.key_column_usage kcu\r\n      JOIN information_schema.table_constraints tc \r\n        ON kcu.constraint_name = tc.constraint_name\r\n      WHERE tc.constraint_type = 'FOREIGN KEY'\r\n        AND kcu.table_name = c.table_name\r\n        AND kcu.column_name = c.column_name\r\n    ))::boolean AS is_foreign_key,\r\n    c.column_default::text AS default_value\r\n  FROM information_schema.columns c\r\n  WHERE c.table_schema = 'public'\r\n    AND c.table_name = $1\r\n  ORDER BY c.ordinal_position;\r\n"
  },
  {
    "function_name": "get_table_policies",
    "arguments": "table_name text",
    "return_type": "TABLE(name text, operation text, using_expression text, check_expression text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    policyname::text AS name,\r\n    cmd::text AS operation,\r\n    qual::text AS using_expression,\r\n    with_check::text AS check_expression\r\n  FROM pg_policies\r\n  WHERE schemaname = 'public'\r\n    AND tablename = $1;\r\n"
  },
  {
    "function_name": "get_table_relationships",
    "arguments": "table_name text",
    "return_type": "TABLE(from_table text, to_table text, from_column text, to_column text, constraint_name text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    tc.table_name::text AS from_table,\r\n    ccu.table_name::text AS to_table,\r\n    kcu.column_name::text AS from_column,\r\n    ccu.column_name::text AS to_column,\r\n    tc.constraint_name::text\r\n  FROM information_schema.table_constraints tc\r\n  JOIN information_schema.key_column_usage kcu\r\n    ON tc.constraint_name = kcu.constraint_name\r\n    AND tc.table_schema = kcu.table_schema\r\n  JOIN information_schema.constraint_column_usage ccu\r\n    ON ccu.constraint_name = tc.constraint_name\r\n    AND ccu.table_schema = tc.table_schema\r\n  WHERE tc.constraint_type = 'FOREIGN KEY'\r\n    AND tc.table_schema = 'public'\r\n    AND tc.table_name = $1;\r\n"
  },
  {
    "function_name": "get_user_activity_history",
    "arguments": "p_user_id uuid, p_start_date timestamp with time zone, p_interval text",
    "return_type": "TABLE(period timestamp with time zone, notes_count bigint, recordings_count bigint, documents_count bigint, quizzes_count bigint, messages_count bigint)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH periods AS (\r\n    SELECT generate_series(\r\n      date_trunc(p_interval, p_start_date),\r\n      date_trunc(p_interval, NOW()),\r\n      ('1 ' || p_interval)::INTERVAL\r\n    ) AS period_start\r\n  ),\r\n  notes_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM notes\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  recordings_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM class_recordings\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  documents_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM documents\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  quizzes_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM quiz_attempts\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  messages_agg AS (\r\n     -- Join with chat_sessions to check ownership if needed, but chat_messages usually has user_id\r\n     -- Schema says chat_messages.user_id references profiles(id) which references auth.users(id)\r\n    SELECT date_trunc(p_interval, timestamp) AS period, COUNT(*) as cnt\r\n    FROM chat_messages\r\n    WHERE user_id = p_user_id AND timestamp >= p_start_date\r\n    GROUP BY 1\r\n  )\r\n  SELECT\r\n    p.period_start,\r\n    COALESCE(n.cnt, 0),\r\n    COALESCE(r.cnt, 0),\r\n    COALESCE(d.cnt, 0),\r\n    COALESCE(q.cnt, 0),\r\n    COALESCE(m.cnt, 0)\r\n  FROM periods p\r\n  LEFT JOIN notes_agg n ON p.period_start = n.period\r\n  LEFT JOIN recordings_agg r ON p.period_start = r.period\r\n  LEFT JOIN documents_agg d ON p.period_start = d.period\r\n  LEFT JOIN quizzes_agg q ON p.period_start = q.period\r\n  LEFT JOIN messages_agg m ON p.period_start = m.period\r\n  ORDER BY p.period_start;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_activity_stats",
    "arguments": "p_user_id uuid, p_days integer",
    "return_type": "TABLE(date text, notes bigint, recordings bigint, documents bigint, messages bigint, total bigint)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH days AS (\r\n    SELECT generate_series(\r\n      date_trunc('day', now() - interval '1 day' * (p_days - 1)),\r\n      date_trunc('day', now()),\r\n      '1 day'::interval\r\n    ) as day\r\n  )\r\n  SELECT\r\n    to_char(d.day, 'Mon DD') as date,\r\n    COALESCE(n.cnt, 0) as notes,\r\n    COALESCE(r.cnt, 0) as recordings,\r\n    COALESCE(doc.cnt, 0) as documents,\r\n    COALESCE(m.cnt, 0) as messages,\r\n    COALESCE(n.cnt, 0) + COALESCE(r.cnt, 0) + COALESCE(doc.cnt, 0) + COALESCE(m.cnt, 0) as total\r\n  FROM days d\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', created_at) as day, count(*) as cnt\r\n    FROM notes WHERE user_id = p_user_id\r\n    AND created_at >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) n ON n.day = d.day\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', created_at) as day, count(*) as cnt\r\n    FROM class_recordings WHERE user_id = p_user_id\r\n    AND created_at >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) r ON r.day = d.day\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', created_at) as day, count(*) as cnt\r\n    FROM documents WHERE user_id = p_user_id\r\n    AND created_at >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) doc ON doc.day = d.day\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', timestamp) as day, count(*) as cnt\r\n    FROM chat_messages WHERE user_id = p_user_id\r\n    AND timestamp >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) m ON m.day = d.day\r\n  ORDER BY d.day;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_stats_with_achievements",
    "arguments": "user_uuid uuid",
    "return_type": "TABLE(user_id uuid, total_xp integer, level integer, current_streak integer, longest_streak integer, total_quizzes_attempted integer, total_quizzes_completed integer, average_score numeric, total_study_time_seconds integer, badges_earned text[], last_activity_date timestamp with time zone, achievements_count bigint)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    us.*,\r\n    COUNT(a.id) as achievements_count\r\n  FROM user_stats us\r\n  LEFT JOIN achievements a ON a.user_id = us.user_id\r\n  WHERE us.user_id = user_uuid\r\n  GROUP BY us.user_id, us.total_xp, us.level, us.current_streak, us.longest_streak,\r\n           us.total_quizzes_attempted, us.total_quizzes_completed, us.average_score,\r\n           us.total_study_time_seconds, us.badges_earned, us.last_activity_date;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_streak",
    "arguments": "p_user_id uuid",
    "return_type": "TABLE(current_streak integer, max_streak integer)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_current_streak INTEGER := 0;\r\n  v_max_streak INTEGER := 0;\r\n  v_dates DATE[];\r\nBEGIN\r\n  -- Get all unique dates with activity from various tables\r\n  -- We prioritize 'created_at' or 'timestamp' columns\r\n  \r\n  SELECT ARRAY(\r\n    SELECT DISTINCT date_trunc('day', activity_time)::DATE\r\n    FROM (\r\n      -- Notes\r\n      SELECT created_at as activity_time FROM notes WHERE user_id = p_user_id\r\n      UNION ALL\r\n      -- Class Recordings\r\n      SELECT created_at as activity_time FROM class_recordings WHERE user_id = p_user_id\r\n      UNION ALL\r\n      -- Documents\r\n      SELECT created_at as activity_time FROM documents WHERE user_id = p_user_id\r\n      UNION ALL\r\n      -- Chat Messages\r\n      SELECT timestamp as activity_time FROM chat_messages WHERE user_id = p_user_id\r\n    ) all_activities\r\n    WHERE activity_time IS NOT NULL\r\n    ORDER BY date_trunc('day', activity_time)::DATE DESC\r\n  ) INTO v_dates;\r\n\r\n  -- Calculate streaks\r\n  IF array_length(v_dates, 1) > 0 THEN\r\n    -- Debug: Check if the most recent activity is today or yesterday\r\n    -- If the latest activity is older than yesterday, streak is 0\r\n    IF v_dates[1] >= (CURRENT_DATE - INTERVAL '1 day') THEN\r\n        v_current_streak := 1;\r\n        \r\n        -- Iterate backwards to find consecutive days\r\n        IF array_length(v_dates, 1) > 1 THEN\r\n            FOR i IN 1..array_length(v_dates, 1) - 1 LOOP\r\n                -- Difference between dates should be 1 day\r\n                IF (v_dates[i] - v_dates[i+1]) = 1 THEN\r\n                    v_current_streak := v_current_streak + 1;\r\n                ELSE\r\n                    -- If the gap is more than 1 day, the streak is broken\r\n                     EXIT;\r\n                END IF;\r\n            END LOOP;\r\n        END IF;\r\n    ELSE\r\n        -- Streak broke if no activity today or yesterday\r\n        v_current_streak := 0;\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Calculate historical max streak\r\n  DECLARE\r\n    temp_streak INTEGER := 0;\r\n    temp_max INTEGER := 0;\r\n  BEGIN\r\n    IF array_length(v_dates, 1) > 0 THEN\r\n        temp_streak := 1;\r\n        temp_max := 1;\r\n        IF array_length(v_dates, 1) > 1 THEN\r\n            FOR i IN 1..array_length(v_dates, 1) - 1 LOOP\r\n                IF (v_dates[i] - v_dates[i+1]) = 1 THEN\r\n                    temp_streak := temp_streak + 1;\r\n                ELSE\r\n                    if temp_streak > temp_max THEN\r\n                        temp_max := temp_streak;\r\n                    END IF;\r\n                    temp_streak := 1;\r\n                END IF;\r\n            END LOOP;\r\n            -- Check last streak\r\n            if temp_streak > temp_max THEN\r\n                temp_max := temp_streak;\r\n            END IF;\r\n        END IF;\r\n        v_max_streak := temp_max;\r\n    END IF;\r\n  END;\r\n\r\n  RETURN QUERY SELECT v_current_streak, v_max_streak;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_unread_count",
    "arguments": "p_user_id uuid",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT COUNT(*)::INTEGER\r\n        FROM social_chat_messages m\r\n        JOIN social_chat_sessions s ON m.session_id = s.id\r\n        WHERE (s.user_id1 = p_user_id OR s.user_id2 = p_user_id)\r\n        AND m.sender_id != p_user_id\r\n        AND m.is_read = FALSE\r\n    );\r\nEND;\r\n"
  },
  {
    "function_name": "get_xp_for_level",
    "arguments": "level_num integer",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN (level_num - 1) * (level_num - 1) * 100;\r\nEND;\r\n"
  },
  {
    "function_name": "guard_log_admin_activity",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  v_role text;\n  v_user_id uuid;\n  v_admin_role text;\n  v_admin_id uuid;\nBEGIN\n  -- try role from JWT\n  BEGIN\n    v_role := auth.jwt() ->> 'role';\n  EXCEPTION WHEN undefined_function THEN\n    v_role := NULL;\n  END;\n\n  -- if role absent or not one of the admin roles, try DB lookup\n  IF v_role IS NULL OR v_role NOT IN ('admin','super_admin','moderator') THEN\n    BEGIN\n      v_user_id := (SELECT auth.uid());\n    EXCEPTION WHEN undefined_function THEN\n      v_user_id := NULL;\n    END;\n\n    IF v_user_id IS NOT NULL THEN\n      SELECT role, id INTO v_admin_role, v_admin_id FROM public.admin_users WHERE user_id = v_user_id LIMIT 1;\n      IF v_admin_role IS NOT NULL AND v_admin_role IN ('admin','super_admin','moderator') THEN\n        -- call existing logging procedure if present, using admin id\n        PERFORM public.log_admin_activity();\n        RETURN COALESCE(NEW, OLD);\n      END IF;\n    END IF;\n\n    -- no admin role found; do nothing\n    RETURN COALESCE(NEW, OLD);\n  ELSE\n    -- JWT indicates admin role; proceed to log using existing procedure\n    PERFORM public.log_admin_activity();\n    RETURN COALESCE(NEW, OLD);\n  END IF;\nEND;\n"
  },
  {
    "function_name": "handle_new_comment_notification",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    post_owner_id UUID;\n    preview_text TEXT;\nBEGIN\n    -- Get post owner (use author_id)\n    SELECT author_id INTO post_owner_id\n    FROM public.social_posts\n    WHERE id = NEW.post_id;\n\n    -- Ignore if commenting on own post\n    IF post_owner_id IS NOT NULL AND post_owner_id != NEW.author_id THEN\n        preview_text := substring(NEW.content from 1 for 50);\n        IF length(NEW.content) > 50 THEN\n            preview_text := preview_text || '...';\n        END IF;\n\n        -- 1. Insert into general 'notifications' (Push)\n        INSERT INTO public.notifications (user_id, type, title, message, data, read)\n        VALUES (\n            post_owner_id,\n            'social_comment',\n            'New Comment',\n            'Someone commented: ' || preview_text,\n            jsonb_build_object('post_id', NEW.post_id, 'comment_id', NEW.id),\n            false\n        );\n\n        -- 2. Insert into 'social_notifications' (Frontend) â€” include title and message\n        INSERT INTO public.social_notifications (user_id, actor_id, type, title, message, post_id, is_read)\n        VALUES (\n            post_owner_id,\n            NEW.author_id,\n            'comment',\n            'New Comment',\n            'Someone commented: ' || preview_text,\n            NEW.post_id,\n            false\n        );\n\n    END IF;\n\n    RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_like_notification",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    post_owner_id UUID;\n    comment_owner_id UUID;\n    notification_body TEXT;\nBEGIN\n    -- CASE 1: Liking a POST\n    IF NEW.post_id IS NOT NULL THEN\n        SELECT author_id INTO post_owner_id FROM public.social_posts WHERE id = NEW.post_id;\n\n        -- social_likes table uses 'user_id' (liker)\n        IF post_owner_id IS NOT NULL AND post_owner_id != NEW.user_id THEN\n            INSERT INTO public.notifications (user_id, type, title, message, data, read)\n            VALUES (post_owner_id, 'social_like', 'New Like', 'Someone liked your post', jsonb_build_object('post_id', NEW.post_id), false);\n\n            INSERT INTO public.social_notifications (user_id, actor_id, type, title, message, post_id, is_read)\n            VALUES (post_owner_id, NEW.user_id, 'like', 'New Like', 'Someone liked your post', NEW.post_id, false);\n        END IF;\n\n    -- CASE 2: Liking a COMMENT\n    ELSIF NEW.comment_id IS NOT NULL THEN\n        SELECT author_id, post_id INTO comment_owner_id, post_owner_id FROM public.social_comments WHERE id = NEW.comment_id;\n\n        IF comment_owner_id IS NOT NULL AND comment_owner_id != NEW.user_id THEN\n            INSERT INTO public.notifications (user_id, type, title, message, data, read)\n            VALUES (comment_owner_id, 'social_like', 'New Like', 'Someone liked your comment', jsonb_build_object('post_id', post_owner_id, 'comment_id', NEW.comment_id), false);\n\n            INSERT INTO public.social_notifications (user_id, actor_id, type, title, message, post_id, is_read)\n            VALUES (comment_owner_id, NEW.user_id, 'like', 'Comment Liked', 'Someone liked your comment', post_owner_id, false);\n        END IF;\n    END IF;\n\n    RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_user",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  BEGIN\n    PERFORM public.handle_new_user_inner(row_to_json(NEW)::jsonb);\n  EXCEPTION WHEN OTHERS THEN\n    INSERT INTO public._trigger_debug_log(event, details)\n    VALUES ('handle_new_user_exception', jsonb_build_object('err', SQLERRM, 'user', row_to_json(NEW)));\n    RAISE; -- rethrow so caller sees error\n  END;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_user_debug",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  BEGIN\n    PERFORM public.handle_new_user();\n  EXCEPTION WHEN OTHERS THEN\n    INSERT INTO public._trigger_debug_log(event, details)\n    VALUES ('handle_new_user_error', jsonb_build_object('err', SQLERRM, 'stack', NULL));\n    RAISE; -- re-raise to surface the error\n  END;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_user_inner",
    "arguments": "p_new jsonb",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  display_name TEXT;\n  user_email TEXT;\nBEGIN\n  user_email := p_new->>'email';\n\n  IF p_new->'raw_user_meta_data' IS NOT NULL AND (p_new->'raw_user_meta_data'->>'full_name') IS NOT NULL THEN\n    display_name := p_new->'raw_user_meta_data'->>'full_name';\n  ELSIF p_new->'raw_user_meta_data' IS NOT NULL AND (p_new->'raw_user_meta_data'->>'name') IS NOT NULL THEN\n    display_name := p_new->'raw_user_meta_data'->>'name';\n  ELSE\n    display_name := SPLIT_PART(user_email, '@', 1);\n  END IF;\n\n  INSERT INTO public.social_users (id, display_name, username, email, avatar_url, bio, is_public, created_at, updated_at)\n  VALUES (\n    (p_new->>'id')::uuid,\n    display_name,\n    LOWER(REGEXP_REPLACE(SPLIT_PART(user_email, '@', 1), '[^a-zA-Z0-9]', '', 'g')) || '_' || SUBSTRING((p_new->>'id'), 1, 6),\n    user_email,\n    COALESCE(p_new->'raw_user_meta_data'->>'avatar_url', p_new->'raw_user_meta_data'->>'picture', NULL),\n    'New to StuddyHub! ðŸ‘‹',\n    true,\n    NOW(),\n    NOW()\n  )\n  ON CONFLICT (id) DO NOTHING;\n\n  INSERT INTO public.profiles (id, full_name, avatar_url, created_at, updated_at)\n  VALUES (\n    (p_new->>'id')::uuid,\n    display_name,\n    COALESCE(p_new->'raw_user_meta_data'->>'avatar_url', p_new->'raw_user_meta_data'->>'picture', NULL),\n    NOW(),\n    NOW()\n  )\n  ON CONFLICT (id) DO UPDATE SET\n    full_name = COALESCE(EXCLUDED.full_name, profiles.full_name),\n    avatar_url = COALESCE(EXCLUDED.avatar_url, profiles.avatar_url),\n    updated_at = NOW();\nEND;\n"
  },
  {
    "function_name": "handle_user_update",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  -- Update social_users with latest metadata if profile exists\r\n  UPDATE public.social_users\r\n  SET\r\n    avatar_url = COALESCE(\r\n      NEW.raw_user_meta_data->>'avatar_url',\r\n      NEW.raw_user_meta_data->>'picture',\r\n      avatar_url\r\n    ),\r\n    updated_at = NOW()\r\n  WHERE id = NEW.id;\r\n\r\n  -- Update profiles table\r\n  UPDATE public.profiles\r\n  SET\r\n    avatar_url = COALESCE(\r\n      NEW.raw_user_meta_data->>'avatar_url',\r\n      NEW.raw_user_meta_data->>'picture',\r\n      avatar_url\r\n    ),\r\n    updated_at = NOW()\r\n  WHERE id = NEW.id;\r\n\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "increment_podcast_listen_count",
    "arguments": "podcast_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE public.ai_podcasts\r\n  SET listen_count = listen_count + 1\r\n  WHERE id = podcast_id;\r\nEND;\r\n"
  },
  {
    "function_name": "increment_podcast_share_count",
    "arguments": "podcast_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE public.ai_podcasts\r\n  SET share_count = share_count + 1,\r\n      updated_at = NOW()\r\n  WHERE id = podcast_id;\r\nEND;\r\n"
  },
  {
    "function_name": "is_podcast_cohost",
    "arguments": "p_podcast_id uuid, p_user_id uuid",
    "return_type": "boolean",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM podcast_cohosts \r\n    WHERE podcast_id = p_podcast_id \r\n    AND user_id = p_user_id \r\n    AND is_active = true\r\n  );\r\nEND;\r\n"
  },
  {
    "function_name": "log_admin_activity",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_actor uuid; -- will hold admin_users.id\r\n  v_actor_user uuid; -- will hold auth.uid() if available\r\n  v_record_id text;\r\n  v_old jsonb;\r\n  v_new jsonb;\r\n  v_payload text;\r\nBEGIN\r\n  -- Try to get actor user id from auth.uid(); if not available, leave NULL\r\n  BEGIN\r\n    v_actor_user := (SELECT auth.uid());\r\n  EXCEPTION WHEN undefined_function THEN\r\n    v_actor_user := NULL;\r\n  END;\r\n\r\n  -- Map to admin_users.id if possible\r\n  IF v_actor_user IS NOT NULL THEN\r\n    SELECT id INTO v_actor FROM public.admin_users WHERE user_id = v_actor_user LIMIT 1;\r\n  ELSE\r\n    v_actor := NULL;\r\n  END IF;\r\n\r\n  IF (TG_OP = 'INSERT') THEN\r\n    v_new := to_jsonb(NEW);\r\n    v_old := NULL;\r\n    v_record_id := NULL;\r\n    BEGIN\r\n      IF (SELECT column_name FROM information_schema.columns WHERE table_schema=TG_TABLE_SCHEMA AND table_name=TG_TABLE_NAME AND column_name='id' LIMIT 1) IS NOT NULL THEN\r\n        v_record_id := NEW.id::text;\r\n      END IF;\r\n    EXCEPTION WHEN others THEN\r\n      v_record_id := NULL;\r\n    END;\r\n  ELSIF (TG_OP = 'UPDATE') THEN\r\n    v_old := to_jsonb(OLD);\r\n    v_new := to_jsonb(NEW);\r\n    BEGIN\r\n      v_record_id := NEW.id::text;\r\n    EXCEPTION WHEN others THEN\r\n      v_record_id := NULL;\r\n    END;\r\n  ELSIF (TG_OP = 'DELETE') THEN\r\n    v_old := to_jsonb(OLD);\r\n    v_new := NULL;\r\n    BEGIN\r\n      v_record_id := OLD.id::text;\r\n    EXCEPTION WHEN others THEN\r\n      v_record_id := NULL;\r\n    END;\r\n  END IF;\r\n\r\n  v_payload := jsonb_build_object(\r\n    'operation', TG_OP,\r\n    'table', TG_TABLE_NAME,\r\n    'record_id', v_record_id,\r\n    'old', v_old,\r\n    'new', v_new\r\n  )::text;\r\n\r\n  -- Insert admin_activity_logs with resolved admin_users.id (v_actor). admin_id is nullable.\r\n  INSERT INTO public.admin_activity_logs(admin_id, action)\r\n  VALUES (v_actor, v_payload);\r\n\r\n  IF (TG_OP = 'DELETE') THEN\r\n    RETURN OLD;\r\n  ELSE\r\n    RETURN NEW;\r\n  END IF;\r\nEND;\r\n"
  },
  {
    "function_name": "log_admin_activity",
    "arguments": "_action text, _target_type text, _target_id uuid, _details jsonb",
    "return_type": "uuid",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "search_path=public",
    "source_code": "\nDECLARE\n    _admin_id UUID;\n    _log_id UUID;\nBEGIN\n    -- Get admin_id from current user\n    SELECT id INTO _admin_id FROM public.admin_users WHERE user_id = auth.uid();\n    \n    IF _admin_id IS NULL THEN\n        RAISE EXCEPTION 'User is not an admin';\n    END IF;\n    \n    -- Insert log entry\n    INSERT INTO public.admin_activity_logs (admin_id, action, target_type, target_id, details)\n    VALUES (_admin_id, _action, _target_type, _target_id, _details)\n    RETURNING id INTO _log_id;\n    \n    RETURN _log_id;\nEND;\n"
  },
  {
    "function_name": "log_schema_query",
    "arguments": "p_user_id uuid, p_operation text, p_table_name text, p_query_intent jsonb, p_success boolean, p_error_message text, p_execution_time_ms integer",
    "return_type": "void",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  INSERT INTO schema_agent_audit (\r\n    user_id, operation, table_name, query_intent,\r\n    success, error_message, execution_time_ms\r\n  ) VALUES (\r\n    p_user_id, p_operation, p_table_name, p_query_intent,\r\n    p_success, p_error_message, p_execution_time_ms\r\n  );\r\n"
  },
  {
    "function_name": "mark_all_notifications_read",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE notifications\r\n  SET read = TRUE, read_at = NOW()\r\n  WHERE user_id = auth.uid() AND read = FALSE;\r\nEND;\r\n"
  },
  {
    "function_name": "mark_notification_read",
    "arguments": "notification_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE notifications\r\n  SET read = TRUE, read_at = NOW()\r\n  WHERE id = notification_id AND user_id = auth.uid();\r\nEND;\r\n"
  },
  {
    "function_name": "mark_session_messages_read",
    "arguments": "p_session_id uuid, p_user_id uuid",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  v_count integer := 0;\nBEGIN\n  INSERT INTO public.social_chat_message_reads (message_id, user_id, read_at)\n  SELECT m.id, p_user_id, NOW()\n  FROM public.social_chat_messages m\n  WHERE m.session_id = p_session_id\n    AND m.sender_id != p_user_id\n  ON CONFLICT (message_id, user_id) DO UPDATE SET read_at = NOW();\n\n  GET DIAGNOSTICS v_count = ROW_COUNT;\n  RETURN v_count;\nEND;\n"
  },
  {
    "function_name": "notify_chat_message",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  session_rec RECORD;\r\n  sender_username text;\r\n  recipient_id uuid;\r\nBEGIN\r\n  -- Get chat session details\r\n  SELECT chat_type, user_id1, user_id2, group_id\r\n  INTO session_rec\r\n  FROM social_chat_sessions\r\n  WHERE id = NEW.session_id;\r\n  \r\n  -- Get sender's username\r\n  SELECT username INTO sender_username\r\n  FROM social_users\r\n  WHERE id = NEW.sender_id;\r\n  \r\n  -- Only notify for P2P messages (group messages handled separately)\r\n  IF session_rec.chat_type = 'p2p' THEN\r\n    -- Determine recipient\r\n    IF session_rec.user_id1 = NEW.sender_id THEN\r\n      recipient_id := session_rec.user_id2;\r\n    ELSE\r\n      recipient_id := session_rec.user_id1;\r\n    END IF;\r\n    \r\n    -- Create notification\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      recipient_id,\r\n      'ai_message',  -- Using ai_message type for chat messages\r\n      'New Message',\r\n      sender_username || ': ' || LEFT(NEW.content, 50) || CASE WHEN LENGTH(NEW.content) > 50 THEN '...' ELSE '' END,\r\n      jsonb_build_object(\r\n        'actor_id', NEW.sender_id,\r\n        'actor_username', sender_username,\r\n        'message_id', NEW.id,\r\n        'session_id', NEW.session_id,\r\n        'chat_type', 'p2p'\r\n      ),\r\n      now()\r\n    );\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_comment_like",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  comment_author_id uuid;\r\n  related_post_id uuid;\r\nBEGIN\r\n  -- Only proceed if this is a comment like\r\n  IF NEW.comment_id IS NOT NULL THEN\r\n    -- FIX: Select author_id instead of user_id from social_comments\r\n    SELECT author_id, post_id INTO comment_author_id, related_post_id\r\n    FROM public.social_comments\r\n    WHERE id = NEW.comment_id;\r\n\r\n    -- Only notify if liker is not the comment author\r\n    IF comment_author_id IS NOT NULL AND comment_author_id != NEW.user_id THEN\r\n      INSERT INTO public.social_notifications (\r\n        user_id,\r\n        actor_id,\r\n        type,\r\n        title,\r\n        message,\r\n        post_id,\r\n        data\r\n      ) VALUES (\r\n        comment_author_id,\r\n        NEW.user_id,\r\n        'like', -- or 'comment_like' if your enum supports it\r\n        'Comment Liked',\r\n        'Someone liked your comment',\r\n        related_post_id,\r\n        jsonb_build_object('comment_id', NEW.comment_id)\r\n      );\r\n    END IF;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_comment_mention",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  mentioned_user RECORD;\r\n  author_username text;\r\nBEGIN\r\n  -- Get author's username\r\n  SELECT username INTO author_username\r\n  FROM social_users\r\n  WHERE id = NEW.author_id;\r\n  \r\n  -- Find all @mentions in the content\r\n  FOR mentioned_user IN\r\n    SELECT su.id, su.username\r\n    FROM social_users su\r\n    WHERE NEW.content ~* ('@' || su.username || '([^a-zA-Z0-9_]|$)')\r\n      AND su.id != NEW.author_id  -- Don't notify self-mentions\r\n  LOOP\r\n    -- Create notification for each mentioned user\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      mentioned_user.id,\r\n      'social_mention',\r\n      'You were mentioned',\r\n      author_username || ' mentioned you in a comment',\r\n      jsonb_build_object(\r\n        'actor_id', NEW.author_id,\r\n        'actor_username', author_username,\r\n        'comment_id', NEW.id,\r\n        'post_id', NEW.post_id,\r\n        'mentioned_username', mentioned_user.username\r\n      ),\r\n      now()\r\n    );\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_group_invite",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  group_name text;\r\n  inviter_username text;\r\nBEGIN\r\n  -- Only notify for pending invites\r\n  IF NEW.status != 'pending' THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Get group name\r\n  SELECT name INTO group_name\r\n  FROM social_groups\r\n  WHERE id = NEW.group_id;\r\n  \r\n  -- Get inviter (group creator or admin - simplified to just use group creator)\r\n  SELECT su.username INTO inviter_username\r\n  FROM social_groups sg\r\n  JOIN social_users su ON sg.created_by = su.id\r\n  WHERE sg.id = NEW.group_id;\r\n  \r\n  -- Create notification\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    data,\r\n    created_at\r\n  ) VALUES (\r\n    NEW.user_id,\r\n    'social_like',  -- Using social_like for group invites\r\n    'Group Invitation',\r\n    'You were invited to join ' || group_name,\r\n    jsonb_build_object(\r\n      'group_id', NEW.group_id,\r\n      'group_name', group_name,\r\n      'membership_id', NEW.id\r\n    ),\r\n    now()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_group_message",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  session_rec RECORD;\r\n  sender_username text;\r\n  member_rec RECORD;\r\n  group_name text;\r\nBEGIN\r\n  -- Get chat session details\r\n  SELECT chat_type, group_id\r\n  INTO session_rec\r\n  FROM social_chat_sessions\r\n  WHERE id = NEW.session_id;\r\n  \r\n  -- Only process group messages\r\n  IF session_rec.chat_type != 'group' OR session_rec.group_id IS NULL THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Get sender's username and group name\r\n  SELECT username INTO sender_username\r\n  FROM social_users\r\n  WHERE id = NEW.sender_id;\r\n  \r\n  SELECT name INTO group_name\r\n  FROM social_groups\r\n  WHERE id = session_rec.group_id;\r\n  \r\n  -- Notify all group members except sender\r\n  FOR member_rec IN\r\n    SELECT user_id\r\n    FROM social_group_members\r\n    WHERE group_id = session_rec.group_id\r\n      AND user_id != NEW.sender_id\r\n      AND status = 'active'\r\n  LOOP\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      member_rec.user_id,\r\n      'ai_message',\r\n      group_name,\r\n      sender_username || ': ' || LEFT(NEW.content, 50) || CASE WHEN LENGTH(NEW.content) > 50 THEN '...' ELSE '' END,\r\n      jsonb_build_object(\r\n        'actor_id', NEW.sender_id,\r\n        'actor_username', sender_username,\r\n        'message_id', NEW.id,\r\n        'session_id', NEW.session_id,\r\n        'group_id', session_rec.group_id,\r\n        'group_name', group_name,\r\n        'chat_type', 'group'\r\n      ),\r\n      now()\r\n    );\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_new_follower",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  follower_username text;\r\nBEGIN\r\n  -- Get follower's username\r\n  SELECT username INTO follower_username\r\n  FROM social_users\r\n  WHERE id = NEW.follower_id;\r\n  \r\n  -- Create notification\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    data,\r\n    created_at\r\n  ) VALUES (\r\n    NEW.following_id,\r\n    'social_like',  -- Using social_like as there's no social_follow type\r\n    'New Follower',\r\n    follower_username || ' started following you',\r\n    jsonb_build_object(\r\n      'actor_id', NEW.follower_id,\r\n      'actor_username', follower_username,\r\n      'follow_id', NEW.id\r\n    ),\r\n    now()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_post_comment",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  post_author_id uuid;\nBEGIN\n  -- Get post author using 'author_id'\n  SELECT author_id INTO post_author_id\n  FROM public.social_posts\n  WHERE id = NEW.post_id;\n\n  -- Only notify if the commenter is not the post author\n  IF post_author_id IS NOT NULL AND post_author_id != NEW.author_id THEN\n    INSERT INTO public.social_notifications (\n      user_id,\n      actor_id,\n      type,\n      title,\n      message,\n      post_id,\n      data\n    ) VALUES (\n      post_author_id,\n      NEW.author_id,\n      'comment',\n      'New Comment',\n      'Someone commented on your post',\n      NEW.post_id,\n      jsonb_build_object('comment_id', NEW.id)\n    );\n  END IF;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "notify_post_like",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  post_author_id uuid;\nBEGIN\n  -- Only proceed if this is a post like (not a comment like)\n  IF NEW.post_id IS NOT NULL THEN\n    SELECT author_id INTO post_author_id\n    FROM public.social_posts\n    WHERE id = NEW.post_id;\n\n    -- Only notify if the liker is not the post author\n    IF post_author_id IS NOT NULL AND post_author_id != NEW.user_id THEN\n      INSERT INTO public.social_notifications (\n        user_id,\n        actor_id,\n        type,\n        title,\n        message,\n        post_id,\n        data\n      ) VALUES (\n        post_author_id,\n        NEW.user_id,\n        'like',\n        'New Like',\n        'Someone liked your post',\n        NEW.post_id,\n        jsonb_build_object('type', 'post_like')\n      );\n    END IF;\n  END IF;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "notify_post_mention",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  mentioned_user RECORD;\r\n  author_username text;\r\n  mention_pattern text;\r\nBEGIN\r\n  -- Get author's username\r\n  SELECT username INTO author_username\r\n  FROM social_users\r\n  WHERE id = NEW.author_id;\r\n  \r\n  -- Find all @mentions in the content\r\n  FOR mentioned_user IN\r\n    SELECT su.id, su.username\r\n    FROM social_users su\r\n    WHERE NEW.content ~* ('@' || su.username || '([^a-zA-Z0-9_]|$)')\r\n      AND su.id != NEW.author_id  -- Don't notify self-mentions\r\n  LOOP\r\n    -- Create notification for each mentioned user\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      mentioned_user.id,\r\n      'social_mention',\r\n      'You were mentioned',\r\n      author_username || ' mentioned you in a post',\r\n      jsonb_build_object(\r\n        'actor_id', NEW.author_id,\r\n        'actor_username', author_username,\r\n        'post_id', NEW.id,\r\n        'mentioned_username', mentioned_user.username\r\n      ),\r\n      now()\r\n    );\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_post_share",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  original_author_id uuid;\r\n  sharer_username text;\r\nBEGIN\r\n  -- Get original post author\r\n  SELECT author_id INTO original_author_id\r\n  FROM social_posts\r\n  WHERE id = NEW.original_post_id;\r\n  \r\n  -- Don't notify if sharing own post\r\n  IF original_author_id = NEW.user_id THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Get sharer's username\r\n  SELECT username INTO sharer_username\r\n  FROM social_users\r\n  WHERE id = NEW.user_id;\r\n  \r\n  -- Create notification\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    data,\r\n    created_at\r\n  ) VALUES (\r\n    original_author_id,\r\n    'social_like',  -- Using social_like for shares\r\n    'Post Shared',\r\n    sharer_username || ' shared your post',\r\n    jsonb_build_object(\r\n      'actor_id', NEW.user_id,\r\n      'actor_username', sharer_username,\r\n      'post_id', NEW.original_post_id,\r\n      'share_id', NEW.id\r\n    ),\r\n    now()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "process_referral_reward",
    "arguments": "p_referee_id uuid, p_referral_code text",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  v_referrer_id UUID;\n  v_referral_id UUID;\n  v_current_sub RECORD;\nBEGIN\n  -- Find referrer by code\n  SELECT id INTO v_referrer_id FROM public.profiles WHERE referral_code = p_referral_code;\n  \n  IF v_referrer_id IS NULL THEN\n    RETURN jsonb_build_object('success', false, 'error', 'Invalid referral code');\n  END IF;\n  \n  IF v_referrer_id = p_referee_id THEN\n    RETURN jsonb_build_object('success', false, 'error', 'Cannot refer yourself');\n  END IF;\n  \n  -- Check if already referred\n  IF EXISTS(SELECT 1 FROM public.referrals WHERE referee_id = p_referee_id) THEN\n    RETURN jsonb_build_object('success', false, 'error', 'Already referred');\n  END IF;\n  \n  -- Create referral record\n  INSERT INTO public.referrals (referrer_id, referee_id, status)\n  VALUES (v_referrer_id, p_referee_id, 'completed')\n  RETURNING id INTO v_referral_id;\n  \n  -- Grant +10 AI credits to referee\n  UPDATE public.profiles\n  SET bonus_ai_credits = COALESCE(bonus_ai_credits, 0) + 10\n  WHERE id = p_referee_id;\n  \n  -- Grant +3 days Scholar to referrer\n  SELECT * INTO v_current_sub FROM public.subscriptions WHERE user_id = v_referrer_id;\n  \n  IF v_current_sub IS NULL THEN\n    -- Create new subscription with 3 days Scholar\n    INSERT INTO public.subscriptions (user_id, plan_type, status, current_period_end)\n    VALUES (v_referrer_id, 'scholar', 'active', now() + interval '3 days');\n  ELSE\n    -- Extend existing subscription\n    UPDATE public.subscriptions\n    SET \n      plan_type = CASE WHEN plan_type = 'free' THEN 'scholar' ELSE plan_type END,\n      current_period_end = GREATEST(COALESCE(current_period_end, now()), now()) + interval '3 days',\n      status = 'active'\n    WHERE user_id = v_referrer_id;\n  END IF;\n  \n  -- Update referrer stats\n  UPDATE public.profiles\n  SET referral_count = COALESCE(referral_count, 0) + 1\n  WHERE id = v_referrer_id;\n  \n  -- Mark referral as reward granted\n  UPDATE public.referrals SET reward_granted = true WHERE id = v_referral_id;\n  \n  RETURN jsonb_build_object('success', true, 'referrer_id', v_referrer_id);\nEND;\n"
  },
  {
    "function_name": "review_flashcard",
    "arguments": "p_flashcard_id uuid, p_user_id uuid, p_quality integer",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    v_ease_factor NUMERIC;\n    v_interval_days INTEGER;\n    v_review_count INTEGER;\nBEGIN\n    -- Get current values\n    SELECT ease_factor, interval_days, review_count\n    INTO v_ease_factor, v_interval_days, v_review_count\n    FROM public.flashcards\n    WHERE id = p_flashcard_id AND user_id = p_user_id;\n\n    -- Update ease factor (SuperMemo 2 algorithm)\n    v_ease_factor := v_ease_factor + (0.1 - (5 - p_quality) * (0.08 + (5 - p_quality) * 0.02));\n    \n    IF v_ease_factor < 1.3 THEN\n        v_ease_factor := 1.3;\n    END IF;\n\n    -- Calculate new interval\n    IF p_quality < 3 THEN\n        v_interval_days := 1; -- Reset if quality is too low\n    ELSE\n        IF v_review_count = 0 THEN\n            v_interval_days := 1;\n        ELSIF v_review_count = 1 THEN\n            v_interval_days := 6;\n        ELSE\n            v_interval_days := ROUND(v_interval_days * v_ease_factor)::INTEGER;\n        END IF;\n    END IF;\n\n    -- Update the flashcard\n    UPDATE public.flashcards\n    SET \n        review_count = review_count + 1,\n        last_reviewed_at = NOW(),\n        next_review_at = NOW() + (v_interval_days || ' days')::INTERVAL,\n        ease_factor = v_ease_factor,\n        interval_days = v_interval_days,\n        updated_at = NOW()\n    WHERE id = p_flashcard_id AND user_id = p_user_id;\nEND;\n"
  },
  {
    "function_name": "send_push_notification",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  subscription_rec RECORD;\r\n  preferences_rec RECORD;\r\n  payload jsonb;\r\n  request_id bigint;\r\nBEGIN\r\n  -- Get user preferences\r\n  SELECT * INTO preferences_rec\r\n  FROM notification_preferences\r\n  WHERE user_id = NEW.user_id;\r\n  \r\n  -- Check if push notifications are enabled\r\n  IF preferences_rec IS NULL OR preferences_rec.push_notifications = false THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Check notification type preference\r\n  IF NEW.type = 'schedule_reminder' AND preferences_rec.schedule_reminders = false THEN\r\n    RETURN NEW;\r\n  ELSIF NEW.type = 'quiz_due' AND preferences_rec.quiz_reminders = false THEN\r\n    RETURN NEW;\r\n  ELSIF NEW.type IN ('social_like', 'social_comment', 'social_mention') AND preferences_rec.social_notifications = false THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Check quiet hours\r\n  IF preferences_rec.quiet_hours_enabled THEN\r\n    IF (CURRENT_TIME >= preferences_rec.quiet_hours_start OR CURRENT_TIME < preferences_rec.quiet_hours_end) THEN\r\n      RETURN NEW;\r\n    END IF;\r\n  END IF;\r\n  \r\n  -- Get all active subscriptions for this user\r\n  FOR subscription_rec IN\r\n    SELECT * FROM notification_subscriptions\r\n    WHERE user_id = NEW.user_id\r\n  LOOP\r\n    -- Build the push notification payload\r\n    payload := jsonb_build_object(\r\n      'title', NEW.title,\r\n      'body', NEW.message,\r\n      'icon', '/icon-192.png',\r\n      'badge', '/badge-72.png',\r\n      'tag', NEW.type,\r\n      'data', jsonb_build_object(\r\n        'id', NEW.id,\r\n        'type', NEW.type,\r\n        'data', COALESCE(NEW.data, '{}'::jsonb)\r\n      ),\r\n      'requireInteraction', (NEW.type IN ('schedule_reminder', 'quiz_due')),\r\n      'timestamp', EXTRACT(EPOCH FROM NOW()) * 1000\r\n    );\r\n    \r\n    -- Send push notification using web-push protocol\r\n    -- This is a simplified version - in production, use the send-notification edge function\r\n    -- or configure a Database Webhook\r\n    \r\n    -- For now, we'll use pg_net to make an async HTTP request to our edge function\r\n    SELECT net.http_post(\r\n      url := current_setting('app.supabase_url', true) || '/functions/v1/send-notification',\r\n      headers := jsonb_build_object(\r\n        'Content-Type', 'application/json',\r\n        'Authorization', 'Bearer ' || current_setting('app.supabase_service_role_key', true)\r\n      ),\r\n      body := jsonb_build_object(\r\n        'user_id', NEW.user_id,\r\n        'type', NEW.type,\r\n        'title', NEW.title,\r\n        'message', NEW.message,\r\n        'data', NEW.data,\r\n        'save_to_db', false\r\n      )\r\n    ) INTO request_id;\r\n    \r\n    -- Exit after first request to avoid duplicate notifications\r\n    EXIT;\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    -- Log error but don't fail the insert\r\n    RAISE WARNING 'Failed to send push notification for notification %: %', NEW.id, SQLERRM;\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "sync_profile_to_social",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  UPDATE public.social_users\n  SET email        = NEW.email,\n      avatar_url   = NEW.avatar_url,\n      display_name = NEW.full_name,   -- map profile.full_name â†’ social.display_name\n      username     = NEW.username,    -- map profile.username â†’ social.username\n      updated_at   = now()\n  WHERE id = NEW.id\n    AND (email        IS DISTINCT FROM NEW.email\n      OR avatar_url   IS DISTINCT FROM NEW.avatar_url\n      OR display_name IS DISTINCT FROM NEW.full_name\n      OR username     IS DISTINCT FROM NEW.username);\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "sync_social_to_profile",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  UPDATE public.profiles\n  SET email       = NEW.email,\n      avatar_url  = NEW.avatar_url,\n      full_name   = NEW.display_name,   -- map display name â†’ profile.full_name\n      username    = NEW.username,       -- map username â†’ profile.username\n      updated_at  = now()\n  WHERE id = NEW.id\n    AND (email       IS DISTINCT FROM NEW.email\n      OR avatar_url  IS DISTINCT FROM NEW.avatar_url\n      OR full_name   IS DISTINCT FROM NEW.display_name\n      OR username    IS DISTINCT FROM NEW.username);\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "update_chat_message_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_chat_session_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  -- Only update if session_id is not null\r\n  IF NEW.session_id IS NOT NULL THEN\r\n    UPDATE social_chat_sessions\r\n    SET last_message_at = NEW.created_at,\r\n        updated_at = NOW()\r\n    WHERE id = NEW.session_id;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_context_size",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    IF NEW.context_summary IS NOT NULL THEN\r\n        NEW.context_size_bytes = LENGTH(NEW.context_summary);\r\n    ELSE\r\n        NEW.context_size_bytes = 0;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_flashcard_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "update_goal_progress",
    "arguments": "goal_id uuid, new_progress integer",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE user_learning_goals \r\n  SET \r\n    progress = new_progress,\r\n    is_completed = (new_progress = 100),\r\n    updated_at = NOW()\r\n  WHERE id = goal_id;\r\nEND;\r\n"
  },
  {
    "function_name": "update_session_last_message",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    UPDATE social_chat_sessions\r\n    SET \r\n        last_message_at = NEW.created_at,\r\n        updated_at = NOW()\r\n    WHERE id = NEW.session_id;\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "validate_and_execute_query",
    "arguments": "p_user_id uuid, p_operation text, p_table_name text, p_columns jsonb, p_conditions jsonb, p_data jsonb, p_limit integer",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_result jsonb;\r\n  v_query text;\r\n  v_has_user_id boolean;\r\nBEGIN\r\n  -- Check if table exists\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM information_schema.tables\r\n    WHERE table_schema = 'public' AND table_name = p_table_name\r\n  ) THEN\r\n    RAISE EXCEPTION 'Table % does not exist', p_table_name;\r\n  END IF;\r\n\r\n  -- Check if table has user_id column\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM information_schema.columns\r\n    WHERE table_schema = 'public'\r\n      AND table_name = p_table_name\r\n      AND column_name = 'user_id'\r\n  ) INTO v_has_user_id;\r\n\r\n  -- For tables with user_id, enforce user isolation\r\n  IF v_has_user_id THEN\r\n    -- Inject user_id condition if not present\r\n    IF p_conditions IS NULL THEN\r\n      p_conditions := jsonb_build_array(\r\n        jsonb_build_object(\r\n          'column', 'user_id',\r\n          'operator', 'eq',\r\n          'value', p_user_id::text\r\n        )\r\n      );\r\n    ELSIF NOT EXISTS (\r\n      SELECT 1 FROM jsonb_array_elements(p_conditions) AS condition\r\n      WHERE condition->>'column' = 'user_id'\r\n    ) THEN\r\n      p_conditions := p_conditions || jsonb_build_array(\r\n        jsonb_build_object(\r\n          'column', 'user_id',\r\n          'operator', 'eq',\r\n          'value', p_user_id::text\r\n        )\r\n      );\r\n    END IF;\r\n\r\n    -- For INSERT, inject user_id into data\r\n    IF p_operation = 'INSERT' AND p_data IS NOT NULL THEN\r\n      p_data := p_data || jsonb_build_object('user_id', p_user_id);\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Execute operation based on type\r\n  CASE p_operation\r\n    WHEN 'SELECT' THEN\r\n      -- Build SELECT query\r\n      v_query := format('SELECT * FROM %I', p_table_name);\r\n      -- Add WHERE conditions\r\n      IF p_conditions IS NOT NULL THEN\r\n        v_query := v_query || ' WHERE ' || build_where_clause(p_conditions);\r\n      END IF;\r\n      -- Add LIMIT\r\n      IF p_limit IS NOT NULL THEN\r\n        v_query := v_query || format(' LIMIT %s', p_limit);\r\n      END IF;\r\n      \r\n      EXECUTE v_query INTO v_result;\r\n      \r\n    WHEN 'INSERT' THEN\r\n      -- Validate required columns\r\n      -- Execute INSERT\r\n      v_query := format(\r\n        'INSERT INTO %I (%s) VALUES (%s) RETURNING *',\r\n        p_table_name,\r\n        (SELECT string_agg(key, ', ') FROM jsonb_object_keys(p_data) AS key),\r\n        (SELECT string_agg(quote_literal(value), ', ') FROM jsonb_each_text(p_data) AS value)\r\n      );\r\n      \r\n      EXECUTE v_query INTO v_result;\r\n      \r\n    WHEN 'UPDATE' THEN\r\n      -- Execute UPDATE with conditions\r\n      v_query := format('UPDATE %I SET ', p_table_name);\r\n      v_query := v_query || (\r\n        SELECT string_agg(format('%I = %L', key, value), ', ')\r\n        FROM jsonb_each_text(p_data)\r\n      );\r\n      IF p_conditions IS NOT NULL THEN\r\n        v_query := v_query || ' WHERE ' || build_where_clause(p_conditions);\r\n      END IF;\r\n      v_query := v_query || ' RETURNING *';\r\n      \r\n      EXECUTE v_query INTO v_result;\r\n      \r\n    WHEN 'DELETE' THEN\r\n      -- Execute DELETE with conditions\r\n      v_query := format('DELETE FROM %I', p_table_name);\r\n      IF p_conditions IS NOT NULL THEN\r\n        v_query := v_query || ' WHERE ' || build_where_clause(p_conditions);\r\n      END IF;\r\n      \r\n      EXECUTE v_query;\r\n      v_result := jsonb_build_object('deleted', true);\r\n      \r\n    ELSE\r\n      RAISE EXCEPTION 'Unsupported operation: %', p_operation;\r\n  END CASE;\r\n\r\n  RETURN v_result;\r\nEND;\r\n"
  }
][
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "Allow authenticated update access to app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "Allow public insert access to app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "Allow public read access to app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "super_admin_delete_app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "super_admin_insert_app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "super_admin_select_app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "app_stats",
    "policyname": "super_admin_update_app_stats",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "content_moderation_log",
    "policyname": "Admins can view all moderation logs",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users\n  WHERE ((admin_users.user_id = auth.uid()) AND ((admin_users.role = 'super_admin'::admin_role) OR (admin_users.role = 'admin'::admin_role) OR (admin_users.role = 'moderator'::admin_role)))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "content_moderation_log",
    "policyname": "Service role can insert moderation logs",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "content_moderation_log",
    "policyname": "Users can view their own moderation logs",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "(auth.uid() = user_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_players",
    "policyname": "Anyone can join as player",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_players",
    "policyname": "Anyone can view players",
    "permissive": "PERMISSIVE",
    "roles": "{anon,authenticated}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_players",
    "policyname": "Users can delete own player",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(user_id = auth.uid())",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_players",
    "policyname": "Users can update own player",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(user_id = auth.uid())",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_questions",
    "policyname": "Anyone can view questions",
    "permissive": "PERMISSIVE",
    "roles": "{anon,authenticated}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_questions",
    "policyname": "Host can update questions",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM live_quiz_sessions\n  WHERE ((live_quiz_sessions.id = live_quiz_questions.session_id) AND (live_quiz_sessions.host_user_id = auth.uid()))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_questions",
    "policyname": "System can create questions",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_sessions",
    "policyname": "Anyone can create sessions",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_sessions",
    "policyname": "Anyone can view sessions",
    "permissive": "PERMISSIVE",
    "roles": "{anon,authenticated}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_sessions",
    "policyname": "Host can delete own sessions",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(host_user_id = auth.uid())",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "live_quiz_sessions",
    "policyname": "Host can update own sessions",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(host_user_id = auth.uid())",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "Enable insert for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "Users can delete own notifications",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "DELETE",
    "using_expression": "(auth.uid() = user_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "Users can update own notifications",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "UPDATE",
    "using_expression": "(auth.uid() = user_id)",
    "with_check": "(auth.uid() = user_id)"
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "Users can view own notifications",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "(auth.uid() = user_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "super_admin_delete_notifications",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = auth.uid()) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "super_admin_insert_notifications",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = auth.uid()) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "super_admin_select_notifications",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = auth.uid()) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "notifications",
    "policyname": "super_admin_update_notifications",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = auth.uid()) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = auth.uid()) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "podcast_chunks",
    "policyname": "Enable insert for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "podcast_chunks",
    "policyname": "Enable select for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "podcast_chunks",
    "policyname": "Enable update for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "podcast_recordings",
    "policyname": "Enable all for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "ALL",
    "using_expression": "true",
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "podcast_recordings",
    "policyname": "Mod access on recordings",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "ALL",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ai_podcasts p\n  WHERE ((p.id = podcast_recordings.podcast_id) AND (p.user_id = auth.uid()))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "podcast_recordings",
    "policyname": "Read access on recordings",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "((EXISTS ( SELECT 1\n   FROM ai_podcasts p\n  WHERE ((p.id = podcast_recordings.podcast_id) AND ((p.is_public = true) OR ((auth.uid() IS NOT NULL) AND (p.user_id = auth.uid())))))) OR ((auth.uid() IS NOT NULL) AND (EXISTS ( SELECT 1\n   FROM podcast_members pm\n  WHERE ((pm.podcast_id = pm.podcast_id) AND (pm.user_id = auth.uid()))))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "referrals",
    "policyname": "System can insert referrals",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "referrals",
    "policyname": "System can update referrals",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "UPDATE",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "referrals",
    "policyname": "Users can view referrals they made",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "(auth.uid() = referrer_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "referrals",
    "policyname": "Users can view referrals they received",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "(auth.uid() = referee_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "Authenticated can update hashtags",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "true",
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "Enable insert for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(auth.uid() IS NOT NULL)"
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "Enable read access for all users",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "super_admin_delete_social_hashtags",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "super_admin_insert_social_hashtags",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "super_admin_select_social_hashtags",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_hashtags",
    "policyname": "super_admin_update_social_hashtags",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "Enable delete for post authors",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "DELETE",
    "using_expression": "(auth.uid() = author_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "Enable insert for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(auth.uid() IS NOT NULL)"
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "Enable read access for all users",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "Enable updates for post metadata",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "true",
    "with_check": "((auth.uid() = author_id) OR ((auth.uid() IS NOT NULL) AND ((likes_count IS NOT NULL) OR (comments_count IS NOT NULL) OR (shares_count IS NOT NULL) OR (views_count IS NOT NULL))))"
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "super_admin_delete_social_posts",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "super_admin_insert_social_posts",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "super_admin_select_social_posts",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_posts",
    "policyname": "super_admin_update_social_posts",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "Authenticated can update followers count",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "true",
    "with_check": "true"
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "Enable insert for authenticated users",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(auth.uid() = id)"
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "Enable read access for all users",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "SELECT",
    "using_expression": "true",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "Enable update for own profile",
    "permissive": "PERMISSIVE",
    "roles": "{public}",
    "cmd": "UPDATE",
    "using_expression": "(auth.uid() = id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "super_admin_delete_social_users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "DELETE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "super_admin_insert_social_users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "using_expression": null,
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "super_admin_select_social_users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "social_users",
    "policyname": "super_admin_update_social_users",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))",
    "with_check": "(EXISTS ( SELECT 1\n   FROM admin_users au\n  WHERE ((au.user_id = ( SELECT auth.uid() AS uid)) AND (au.role = 'super_admin'::admin_role))))"
  }
][
  {
    "table_name": "app_stats",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "'00000000-0000-0000-0000-000000000001'::uuid"
  },
  {
    "table_name": "app_stats",
    "column_name": "active_users",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'0+'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "notes_processed",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'0+'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "uptime",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'99.9%'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "user_rating",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'4.9/5'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "content_preview",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "content_type",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "decision",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "reason",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "confidence",
    "data_type": "double precision",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "ai_analysis",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "educational_score",
    "data_type": "double precision",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "category",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "topics",
    "data_type": "ARRAY",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "session_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "display_name",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "join_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "score",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "is_host",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "false"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "last_answered_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "is_playing",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "true"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "is_mediator",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "false"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "current_question_idx",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "individual_start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "individual_end_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "questions_attempted",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "questions_correct",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "total_time_spent",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "status",
    "data_type": "character varying",
    "is_nullable": "YES",
    "column_default": "'playing'::character varying"
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "session_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "question_index",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "question_text",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "options",
    "data_type": "jsonb",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "correct_answer",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "explanation",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "end_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "time_limit",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "30"
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": "'pending'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "quiz_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "host_user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'waiting'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "end_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "join_code",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "host_role",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'participant'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "advance_mode",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'auto'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "config",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": "'{\"auto_advance\": true, \"question_time_limit\": 30}'::jsonb"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "quiz_mode",
    "data_type": "character varying",
    "is_nullable": "YES",
    "column_default": "'synchronized'::character varying"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "scheduled_start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "allow_late_join",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "true"
  },
  {
    "table_name": "notifications",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "uuid_generate_v4()"
  },
  {
    "table_name": "notifications",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "type",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "title",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "message",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "data",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "read",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "false"
  },
  {
    "table_name": "notifications",
    "column_name": "read_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "notifications",
    "column_name": "expires_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "podcast_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "upload_session_id",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "chunk_index",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "total_chunks",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "storage_path",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "file_size",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "mime_type",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "checksum",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": "'uploaded'::text"
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "uploader_user_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "podcast_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "session_id",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'in_progress'::text"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "started_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "ended_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "duration_seconds",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "final_audio_url",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "storage_path",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "metadata",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "referrals",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "referrals",
    "column_name": "referrer_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "referrals",
    "column_name": "referee_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  }
][
  {
    "table_name": "app_stats",
    "trigger_name": "update_app_stats_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_timestamp()"
  },
  {
    "table_name": "chat_messages",
    "trigger_name": "chat_message_insert_count_trigger",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_chat_session_message_count()"
  },
  {
    "table_name": "flashcards",
    "trigger_name": "update_flashcards_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_flashcard_updated_at()"
  },
  {
    "table_name": "live_quiz_sessions",
    "trigger_name": "update_live_quiz_sessions_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_updated_at()"
  },
  {
    "table_name": "notifications",
    "trigger_name": "send-push-on-notification",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION supabase_functions.http_request('https://kegsrvnywshxyucgjxml.supabase.co/functions/v1/send-notification', 'POST', '{\"Content-type\":\"application/json\",\"Authorization\":\"Bearer REDACTED_SERVICE_ROLE_KEY\"}', '{}', '5000')"
  },
  {
    "table_name": "notifications",
    "trigger_name": "trigger_send_push_notification",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION send_push_notification()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "on_profile_created_assign_referral",
    "event": "INSERT",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION assign_referral_code()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_sync_profile_to_social",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION sync_profile_to_social()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_update_app_stats_on_profiles",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_app_stats_function()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_update_app_stats_on_profiles",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_app_stats_function()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_update_app_stats_on_profiles_update",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_app_stats_function()"
  },
  {
    "table_name": "social_chat_message_reads",
    "trigger_name": "trg_social_chat_message_reads_after_ins_upd",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_chat_message_reads_propagate()"
  },
  {
    "table_name": "social_chat_message_reads",
    "trigger_name": "trg_social_chat_message_reads_after_ins_upd",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_chat_message_reads_propagate()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_chat_message_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_chat_message_timestamp()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_notify_chat_message",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_chat_message()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_notify_group_message",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_group_message()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_update_session_last_message",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_session_last_message()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "update_chat_session_timestamp_trigger",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_chat_session_timestamp()"
  },
  {
    "table_name": "social_comments",
    "trigger_name": "on_social_comment_insert",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION handle_new_comment_notification()"
  },
  {
    "table_name": "social_comments",
    "trigger_name": "trigger_update_comment_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_comment_counts()"
  },
  {
    "table_name": "social_comments",
    "trigger_name": "trigger_update_comment_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_comment_counts()"
  },
  {
    "table_name": "social_follows",
    "trigger_name": "trigger_notify_new_follower",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_new_follower()"
  },
  {
    "table_name": "social_follows",
    "trigger_name": "trigger_update_follow_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_follow_counts()"
  },
  {
    "table_name": "social_follows",
    "trigger_name": "trigger_update_follow_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_follow_counts()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trg_social_group_members_after_del",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_group_members_propagate()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trg_social_group_members_after_ins",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_group_members_propagate()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trg_social_group_members_after_upd",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_group_members_propagate()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trigger_notify_group_invite",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_group_invite()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trigger_update_group_member_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_group_member_counts()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trigger_update_group_member_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_group_member_counts()"
  },
  {
    "table_name": "social_likes",
    "trigger_name": "on_social_like_insert",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION handle_new_like_notification()"
  },
  {
    "table_name": "social_likes",
    "trigger_name": "trigger_update_like_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_like_counts()"
  },
  {
    "table_name": "social_likes",
    "trigger_name": "trigger_update_like_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_like_counts()"
  },
  {
    "table_name": "social_posts",
    "trigger_name": "trigger_notify_post_mention",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_post_mention()"
  },
  {
    "table_name": "social_posts",
    "trigger_name": "trigger_update_post_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_post_counts()"
  },
  {
    "table_name": "social_posts",
    "trigger_name": "trigger_update_post_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_post_counts()"
  },
  {
    "table_name": "social_users",
    "trigger_name": "trg_sync_social_to_profile",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION sync_social_to_profile()"
  }
][
  {
    "function_name": "_social_groups_recalc_members_count_for",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "apply_code_night_promo",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "cleanup_old_notifications",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "cleanup_old_podcast_chunks",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "expire_old_podcast_invites",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_user_inner",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "increment_podcast_listen_count",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "increment_podcast_share_count",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "log_schema_query",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "mark_all_notifications_read",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "mark_notification_read",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "review_flashcard",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_goal_progress",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_or_create_group_chat_session",
    "return_type": "uuid",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "log_admin_activity",
    "return_type": "uuid",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "_social_chat_message_reads_propagate",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "_social_group_members_propagate",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "assign_referral_code",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "cleanup_podcast_cohosts",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "create_social_user_profile",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "guard_log_admin_activity",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_comment_notification",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_like_notification",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_user",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_user_debug",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_user_update",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "log_admin_activity",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_chat_message",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_comment_like",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_comment_mention",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_group_invite",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_group_message",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_new_follower",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_comment",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_like",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_mention",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_share",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "send_push_notification",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "sync_profile_to_social",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "sync_social_to_profile",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_chat_message_timestamp",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_chat_session_timestamp",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_context_size",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_flashcard_updated_at",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_session_last_message",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_updated_at",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_updated_at_column",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "build_where_clause",
    "return_type": "text",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "generate_referral_code",
    "return_type": "text",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "generate_unique_username",
    "return_type": "text",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_learning_velocity",
    "return_type": "TABLE(week text, items bigint)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_user_stats_with_achievements",
    "return_type": "TABLE(user_id uuid, total_xp integer, level integer, current_streak integer, longest_streak integer, total_quizzes_attempted integer, total_quizzes_completed integer, average_score numeric, total_study_time_seconds integer, badges_earned text[], last_activity_date timestamp with time zone, achievements_count bigint)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_schema_tables",
    "return_type": "TABLE(table_name text, table_type text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "get_user_activity_history",
    "return_type": "TABLE(period timestamp with time zone, notes_count bigint, recordings_count bigint, documents_count bigint, quizzes_count bigint, messages_count bigint)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_table_columns",
    "return_type": "TABLE(name text, type text, nullable boolean, is_primary_key boolean, is_foreign_key boolean, default_value text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "get_table_policies",
    "return_type": "TABLE(name text, operation text, using_expression text, check_expression text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "check_podcast_permissions",
    "return_type": "TABLE(is_host boolean, is_cohost boolean, can_speak boolean, can_moderate boolean)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_suggested_users",
    "return_type": "TABLE(id uuid, username text, display_name text, avatar_url text, bio text, interests text[], followers_count integer, following_count integer, posts_count integer, is_verified boolean, last_active timestamp with time zone, created_at timestamp with time zone, recommendation_score numeric)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_due_flashcards",
    "return_type": "TABLE(id uuid, front text, back text, category text, difficulty text, hint text, review_count integer, ease_factor numeric)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_table_relationships",
    "return_type": "TABLE(from_table text, to_table text, from_column text, to_column text, constraint_name text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "get_user_activity_stats",
    "return_type": "TABLE(date text, notes bigint, recordings bigint, documents bigint, messages bigint, total bigint)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_user_streak",
    "return_type": "TABLE(current_streak integer, max_streak integer)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "approve_group_member",
    "return_type": "jsonb",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "process_referral_reward",
    "return_type": "jsonb",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "validate_and_execute_query",
    "return_type": "jsonb",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_session_unread_count",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_user_unread_count",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_xp_for_level",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "mark_session_messages_read",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "check_user_is_cohost",
    "return_type": "boolean",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "is_podcast_cohost",
    "return_type": "boolean",
    "security": "INVOKER",
    "language": "plpgsql"
  }
][
  {
    "extension_name": "pg_net",
    "current_schema": "public",
    "version": "0.14.0"
  }
][
  {
    "extension_name": "pg_net",
    "current_schema": "public",
    "version": "0.14.0"
  }
]
[
  {
    "function_name": "_social_groups_recalc_members_count_for",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "apply_code_night_promo",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "cleanup_old_notifications",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "cleanup_old_podcast_chunks",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "expire_old_podcast_invites",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_user_inner",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "increment_podcast_listen_count",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "increment_podcast_share_count",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "log_schema_query",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "mark_all_notifications_read",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "mark_notification_read",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "review_flashcard",
    "return_type": "void",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_goal_progress",
    "return_type": "void",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_or_create_group_chat_session",
    "return_type": "uuid",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "log_admin_activity",
    "return_type": "uuid",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "_social_chat_message_reads_propagate",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "_social_group_members_propagate",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "assign_referral_code",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "cleanup_podcast_cohosts",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "create_social_user_profile",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "guard_log_admin_activity",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_comment_notification",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_like_notification",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_user",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_new_user_debug",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "handle_user_update",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "log_admin_activity",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_chat_message",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_comment_like",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_comment_mention",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_group_invite",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_group_message",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_new_follower",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_comment",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_like",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_mention",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "notify_post_share",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "send_push_notification",
    "return_type": "trigger",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "sync_profile_to_social",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "sync_social_to_profile",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_chat_message_timestamp",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_chat_session_timestamp",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_context_size",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_flashcard_updated_at",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_session_last_message",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_updated_at",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "update_updated_at_column",
    "return_type": "trigger",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "build_where_clause",
    "return_type": "text",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "generate_referral_code",
    "return_type": "text",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "generate_unique_username",
    "return_type": "text",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_learning_velocity",
    "return_type": "TABLE(week text, items bigint)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_user_stats_with_achievements",
    "return_type": "TABLE(user_id uuid, total_xp integer, level integer, current_streak integer, longest_streak integer, total_quizzes_attempted integer, total_quizzes_completed integer, average_score numeric, total_study_time_seconds integer, badges_earned text[], last_activity_date timestamp with time zone, achievements_count bigint)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_schema_tables",
    "return_type": "TABLE(table_name text, table_type text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "get_user_activity_history",
    "return_type": "TABLE(period timestamp with time zone, notes_count bigint, recordings_count bigint, documents_count bigint, quizzes_count bigint, messages_count bigint)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_table_columns",
    "return_type": "TABLE(name text, type text, nullable boolean, is_primary_key boolean, is_foreign_key boolean, default_value text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "get_table_policies",
    "return_type": "TABLE(name text, operation text, using_expression text, check_expression text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "check_podcast_permissions",
    "return_type": "TABLE(is_host boolean, is_cohost boolean, can_speak boolean, can_moderate boolean)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_suggested_users",
    "return_type": "TABLE(id uuid, username text, display_name text, avatar_url text, bio text, interests text[], followers_count integer, following_count integer, posts_count integer, is_verified boolean, last_active timestamp with time zone, created_at timestamp with time zone, recommendation_score numeric)",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_due_flashcards",
    "return_type": "TABLE(id uuid, front text, back text, category text, difficulty text, hint text, review_count integer, ease_factor numeric)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_table_relationships",
    "return_type": "TABLE(from_table text, to_table text, from_column text, to_column text, constraint_name text)",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "get_user_activity_stats",
    "return_type": "TABLE(date text, notes bigint, recordings bigint, documents bigint, messages bigint, total bigint)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_user_streak",
    "return_type": "TABLE(current_streak integer, max_streak integer)",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "approve_group_member",
    "return_type": "jsonb",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "process_referral_reward",
    "return_type": "jsonb",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "validate_and_execute_query",
    "return_type": "jsonb",
    "security": "SECURITY DEFINER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_session_unread_count",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_user_unread_count",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "get_xp_for_level",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "mark_session_messages_read",
    "return_type": "integer",
    "security": "INVOKER",
    "language": "plpgsql"
  },
  {
    "function_name": "check_user_is_cohost",
    "return_type": "boolean",
    "security": "SECURITY DEFINER",
    "language": "sql"
  },
  {
    "function_name": "is_podcast_cohost",
    "return_type": "boolean",
    "security": "INVOKER",
    "language": "plpgsql"
  }
][
  {
    "table_name": "app_stats",
    "trigger_name": "update_app_stats_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_timestamp()"
  },
  {
    "table_name": "chat_messages",
    "trigger_name": "chat_message_insert_count_trigger",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_chat_session_message_count()"
  },
  {
    "table_name": "flashcards",
    "trigger_name": "update_flashcards_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_flashcard_updated_at()"
  },
  {
    "table_name": "live_quiz_sessions",
    "trigger_name": "update_live_quiz_sessions_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_updated_at()"
  },
  {
    "table_name": "notifications",
    "trigger_name": "send-push-on-notification",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION supabase_functions.http_request('https://kegsrvnywshxyucgjxml.supabase.co/functions/v1/send-notification', 'POST', '{\"Content-type\":\"application/json\",\"Authorization\":\"Bearer REDACTED_SERVICE_ROLE_KEY\"}', '{}', '5000')"
  },
  {
    "table_name": "notifications",
    "trigger_name": "trigger_send_push_notification",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION send_push_notification()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "on_profile_created_assign_referral",
    "event": "INSERT",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION assign_referral_code()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_sync_profile_to_social",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION sync_profile_to_social()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_update_app_stats_on_profiles",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_app_stats_function()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_update_app_stats_on_profiles",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_app_stats_function()"
  },
  {
    "table_name": "profiles",
    "trigger_name": "trg_update_app_stats_on_profiles_update",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_app_stats_function()"
  },
  {
    "table_name": "social_chat_message_reads",
    "trigger_name": "trg_social_chat_message_reads_after_ins_upd",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_chat_message_reads_propagate()"
  },
  {
    "table_name": "social_chat_message_reads",
    "trigger_name": "trg_social_chat_message_reads_after_ins_upd",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_chat_message_reads_propagate()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_chat_message_updated_at",
    "event": "UPDATE",
    "timing": "BEFORE",
    "function_call": "EXECUTE FUNCTION update_chat_message_timestamp()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_notify_chat_message",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_chat_message()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_notify_group_message",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_group_message()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "trigger_update_session_last_message",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_session_last_message()"
  },
  {
    "table_name": "social_chat_messages",
    "trigger_name": "update_chat_session_timestamp_trigger",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_chat_session_timestamp()"
  },
  {
    "table_name": "social_comments",
    "trigger_name": "on_social_comment_insert",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION handle_new_comment_notification()"
  },
  {
    "table_name": "social_comments",
    "trigger_name": "trigger_update_comment_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_comment_counts()"
  },
  {
    "table_name": "social_comments",
    "trigger_name": "trigger_update_comment_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_comment_counts()"
  },
  {
    "table_name": "social_follows",
    "trigger_name": "trigger_notify_new_follower",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_new_follower()"
  },
  {
    "table_name": "social_follows",
    "trigger_name": "trigger_update_follow_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_follow_counts()"
  },
  {
    "table_name": "social_follows",
    "trigger_name": "trigger_update_follow_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_follow_counts()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trg_social_group_members_after_del",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_group_members_propagate()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trg_social_group_members_after_ins",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_group_members_propagate()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trg_social_group_members_after_upd",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION _social_group_members_propagate()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trigger_notify_group_invite",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_group_invite()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trigger_update_group_member_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_group_member_counts()"
  },
  {
    "table_name": "social_group_members",
    "trigger_name": "trigger_update_group_member_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_group_member_counts()"
  },
  {
    "table_name": "social_likes",
    "trigger_name": "on_social_like_insert",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION handle_new_like_notification()"
  },
  {
    "table_name": "social_likes",
    "trigger_name": "trigger_update_like_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_like_counts()"
  },
  {
    "table_name": "social_likes",
    "trigger_name": "trigger_update_like_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_like_counts()"
  },
  {
    "table_name": "social_posts",
    "trigger_name": "trigger_notify_post_mention",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION notify_post_mention()"
  },
  {
    "table_name": "social_posts",
    "trigger_name": "trigger_update_post_counts",
    "event": "DELETE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_post_counts()"
  },
  {
    "table_name": "social_posts",
    "trigger_name": "trigger_update_post_counts",
    "event": "INSERT",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION update_post_counts()"
  },
  {
    "table_name": "social_users",
    "trigger_name": "trg_sync_social_to_profile",
    "event": "UPDATE",
    "timing": "AFTER",
    "function_call": "EXECUTE FUNCTION sync_social_to_profile()"
  }
][
  {
    "table_name": "app_stats",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "'00000000-0000-0000-0000-000000000001'::uuid"
  },
  {
    "table_name": "app_stats",
    "column_name": "active_users",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'0+'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "notes_processed",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'0+'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "uptime",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'99.9%'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "user_rating",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'4.9/5'::text"
  },
  {
    "table_name": "app_stats",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "content_preview",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "content_type",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "decision",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "reason",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "confidence",
    "data_type": "double precision",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "ai_analysis",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "educational_score",
    "data_type": "double precision",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "category",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "topics",
    "data_type": "ARRAY",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "content_moderation_log",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "session_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "display_name",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "join_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "score",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "is_host",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "false"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "last_answered_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "is_playing",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "true"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "is_mediator",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "false"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "current_question_idx",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "individual_start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "individual_end_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "questions_attempted",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "questions_correct",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "total_time_spent",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0"
  },
  {
    "table_name": "live_quiz_players",
    "column_name": "status",
    "data_type": "character varying",
    "is_nullable": "YES",
    "column_default": "'playing'::character varying"
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "session_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "question_index",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "question_text",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "options",
    "data_type": "jsonb",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "correct_answer",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "explanation",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "end_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "time_limit",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "30"
  },
  {
    "table_name": "live_quiz_questions",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": "'pending'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "quiz_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "host_user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'waiting'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "end_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "join_code",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "host_role",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'participant'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "advance_mode",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'auto'::text"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "config",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": "'{\"auto_advance\": true, \"question_time_limit\": 30}'::jsonb"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "quiz_mode",
    "data_type": "character varying",
    "is_nullable": "YES",
    "column_default": "'synchronized'::character varying"
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "scheduled_start_time",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "live_quiz_sessions",
    "column_name": "allow_late_join",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "true"
  },
  {
    "table_name": "notifications",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "uuid_generate_v4()"
  },
  {
    "table_name": "notifications",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "type",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "title",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "message",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "data",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "read",
    "data_type": "boolean",
    "is_nullable": "YES",
    "column_default": "false"
  },
  {
    "table_name": "notifications",
    "column_name": "read_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "notifications",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "notifications",
    "column_name": "expires_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "podcast_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "upload_session_id",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "chunk_index",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "total_chunks",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "storage_path",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "file_size",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "mime_type",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "checksum",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": "'uploaded'::text"
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "uploader_user_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_chunks",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "podcast_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "session_id",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "user_id",
    "data_type": "uuid",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "status",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": "'in_progress'::text"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "started_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "ended_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "duration_seconds",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "final_audio_url",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "storage_path",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "metadata",
    "data_type": "jsonb",
    "is_nullable": "YES",
    "column_default": null
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "podcast_recordings",
    "column_name": "updated_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "now()"
  },
  {
    "table_name": "referrals",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()"
  },
  {
    "table_name": "referrals",
    "column_name": "referrer_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  },
  {
    "table_name": "referrals",
    "column_name": "referee_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null
  }
][
  {
    "function_name": "_social_chat_message_reads_propagate",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  -- Only update if the message exists and the reader is not the sender\n  UPDATE public.social_chat_messages\n  SET\n    is_read = TRUE,\n    read_at = GREATEST(COALESCE(read_at, 'epoch'::timestamptz), NEW.read_at)\n  WHERE id = NEW.message_id\n    AND (sender_id IS DISTINCT FROM NEW.user_id);\n\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "_social_group_members_propagate",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    PERFORM public._social_groups_recalc_members_count_for(NEW.group_id);\n    RETURN NEW;\n  ELSIF TG_OP = 'DELETE' THEN\n    PERFORM public._social_groups_recalc_members_count_for(OLD.group_id);\n    RETURN OLD;\n  ELSIF TG_OP = 'UPDATE' THEN\n    -- If group_id changed, recalc both\n    IF OLD.group_id IS DISTINCT FROM NEW.group_id THEN\n      PERFORM public._social_groups_recalc_members_count_for(OLD.group_id);\n      PERFORM public._social_groups_recalc_members_count_for(NEW.group_id);\n    ELSIF OLD.status IS DISTINCT FROM NEW.status THEN\n      -- status changed for same group\n      PERFORM public._social_groups_recalc_members_count_for(NEW.group_id);\n    END IF;\n    RETURN NEW;\n  END IF;\n\n  RETURN NULL;\nEND;\n"
  },
  {
    "function_name": "_social_groups_recalc_members_count_for",
    "arguments": "p_group_id uuid",
    "return_type": "void",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\n  UPDATE public.social_groups g\n  SET members_count = COALESCE(sub.cnt, 0)\n  FROM (\n    SELECT COUNT(*) AS cnt\n    FROM public.social_group_members\n    WHERE status = 'active' AND group_id = p_group_id\n  ) AS sub\n  WHERE g.id = p_group_id;\n"
  },
  {
    "function_name": "apply_code_night_promo",
    "arguments": "p_user_id uuid, p_promo_code text",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  -- Security check: Ensure the user is applying it to their own account\r\n  IF auth.uid() <> p_user_id THEN\r\n    RAISE EXCEPTION 'Not authorized';\r\n  END IF;\r\n\r\n  -- Validate Promo Code Server-Side\r\n  IF UPPER(TRIM(p_promo_code)) <> 'CODENIGHT2026' THEN\r\n    RAISE EXCEPTION 'Invalid promo code';\r\n  END IF;\r\n\r\n  -- Insert or update the subscription for the user\r\n  INSERT INTO subscriptions (user_id, plan_type, status, current_period_end)\r\n  VALUES (p_user_id, 'genius', 'active', NOW() + INTERVAL '1 month')\r\n  ON CONFLICT (user_id)\r\n  DO UPDATE SET\r\n    plan_type = 'genius',\r\n    status = 'active',\r\n    -- Extend current period if already valid, or set to 1 month from now\r\n    current_period_end = GREATEST(COALESCE(subscriptions.current_period_end, NOW()), NOW() + INTERVAL '1 month');\r\nEND;\r\n"
  },
  {
    "function_name": "approve_group_member",
    "arguments": "p_membership_id uuid, p_group_id uuid, p_user_id uuid, p_approver_id uuid",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_result JSONB;\r\n  v_group_name TEXT;\r\n  v_member_username TEXT;\r\nBEGIN\r\n  -- Check if approver is admin/moderator of the group\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM social_group_members \r\n    WHERE group_id = p_group_id \r\n    AND user_id = p_approver_id \r\n    AND role IN ('admin', 'moderator')\r\n    AND status = 'active'\r\n  ) THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', 'Not authorized to approve members'\r\n    );\r\n  END IF;\r\n\r\n  -- Update the membership status\r\n  UPDATE social_group_members \r\n  SET status = 'active'\r\n  WHERE id = p_membership_id\r\n    AND group_id = p_group_id\r\n    AND user_id = p_user_id\r\n    AND status = 'pending';\r\n\r\n  -- Check if update succeeded\r\n  IF NOT FOUND THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', 'Membership not found or not pending'\r\n    );\r\n  END IF;\r\n\r\n  -- Get group name for notification\r\n  SELECT name INTO v_group_name \r\n  FROM social_groups \r\n  WHERE id = p_group_id;\r\n\r\n  -- Get member username for notification\r\n  SELECT username INTO v_member_username \r\n  FROM social_users \r\n  WHERE id = p_user_id;\r\n\r\n  -- Send notification\r\n  INSERT INTO social_notifications (\r\n    user_id, type, title, message, data\r\n  ) VALUES (\r\n    p_user_id,\r\n    'group_invite',\r\n    'Request Approved',\r\n    'Your request to join \"' || v_group_name || '\" has been approved!',\r\n    jsonb_build_object('group_id', p_group_id)\r\n  );\r\n\r\n  RETURN jsonb_build_object(\r\n    'success', true,\r\n    'message', 'Member approved successfully'\r\n  );\r\nEND;\r\n"
  },
  {
    "function_name": "assign_referral_code",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  new_code TEXT;\r\n  code_exists BOOLEAN;\r\nBEGIN\r\n  -- Only assign if referral_code is NULL\r\n  IF NEW.referral_code IS NULL THEN\r\n    LOOP\r\n      -- Generate a random 8-character code\r\n      new_code := UPPER(SUBSTR(MD5(RANDOM()::TEXT), 1, 8));\r\n      \r\n      -- Check if this code already exists (use table qualification to avoid ambiguity)\r\n      SELECT EXISTS (\r\n        SELECT 1 \r\n        FROM public.profiles p \r\n        WHERE p.referral_code = new_code\r\n      ) INTO code_exists;\r\n      \r\n      -- Exit loop if code is unique\r\n      EXIT WHEN NOT code_exists;\r\n    END LOOP;\r\n    \r\n    NEW.referral_code := new_code;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "build_where_clause",
    "arguments": "conditions jsonb",
    "return_type": "text",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_where_parts text[];\r\n  v_condition jsonb;\r\n  v_column text;\r\n  v_operator text;\r\n  v_value text;\r\n  v_part text;\r\nBEGIN\r\n  FOR v_condition IN SELECT * FROM jsonb_array_elements(conditions)\r\n  LOOP\r\n    v_column := v_condition->>'column';\r\n    v_operator := v_condition->>'operator';\r\n    v_value := v_condition->>'value';\r\n    \r\n    CASE v_operator\r\n      WHEN 'eq' THEN v_part := format('%I = %L', v_column, v_value);\r\n      WHEN 'neq' THEN v_part := format('%I != %L', v_column, v_value);\r\n      WHEN 'gt' THEN v_part := format('%I > %L', v_column, v_value);\r\n      WHEN 'gte' THEN v_part := format('%I >= %L', v_column, v_value);\r\n      WHEN 'lt' THEN v_part := format('%I < %L', v_column, v_value);\r\n      WHEN 'lte' THEN v_part := format('%I <= %L', v_column, v_value);\r\n      WHEN 'like' THEN v_part := format('%I LIKE %L', v_column, v_value);\r\n      WHEN 'ilike' THEN v_part := format('%I ILIKE %L', v_column, v_value);\r\n      WHEN 'in' THEN v_part := format('%I = ANY(%L::text[])', v_column, v_value);\r\n      WHEN 'is' THEN v_part := format('%I IS %s', v_column, CASE WHEN v_value = 'null' THEN 'NULL' ELSE v_value END);\r\n      ELSE v_part := format('%I = %L', v_column, v_value);\r\n    END CASE;\r\n    \r\n    v_where_parts := array_append(v_where_parts, v_part);\r\n  END LOOP;\r\n  \r\n  RETURN array_to_string(v_where_parts, ' AND ');\r\nEND;\r\n"
  },
  {
    "function_name": "check_podcast_permissions",
    "arguments": "p_podcast_id uuid, p_user_id uuid",
    "return_type": "TABLE(is_host boolean, is_cohost boolean, can_speak boolean, can_moderate boolean)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_podcast ai_podcasts%ROWTYPE;\r\n  v_cohost podcast_cohosts%ROWTYPE;\r\nBEGIN\r\n  -- Get podcast info\r\n  SELECT * INTO v_podcast \r\n  FROM ai_podcasts \r\n  WHERE id = p_podcast_id;\r\n  \r\n  -- Check if user is the podcast creator\r\n  IF v_podcast.user_id = p_user_id THEN\r\n    RETURN QUERY SELECT true, false, true, true;\r\n    RETURN;\r\n  END IF;\r\n  \r\n  -- Check if user is a co-host\r\n  SELECT * INTO v_cohost\r\n  FROM podcast_cohosts\r\n  WHERE podcast_id = p_podcast_id\r\n    AND user_id = p_user_id\r\n    AND is_active = true;\r\n  \r\n  IF FOUND THEN\r\n    RETURN QUERY SELECT \r\n      false,\r\n      true,\r\n      'speak' = ANY(v_cohost.permissions),\r\n      'moderate' = ANY(v_cohost.permissions);\r\n    RETURN;\r\n  END IF;\r\n  \r\n  -- Default: regular listener\r\n  RETURN QUERY SELECT false, false, false, false;\r\nEND;\r\n"
  },
  {
    "function_name": "check_user_is_cohost",
    "arguments": "p_podcast_id uuid, p_user_id uuid",
    "return_type": "boolean",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\n  SELECT EXISTS (\n    SELECT 1 FROM public.podcast_members\n    WHERE podcast_id = p_podcast_id\n      AND user_id = p_user_id\n      AND role = 'co-host'\n  );\n"
  },
  {
    "function_name": "cleanup_old_notifications",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  DELETE FROM notifications\r\n  WHERE created_at < NOW() - INTERVAL '30 days'\r\n  AND read = TRUE;\r\n  \r\n  DELETE FROM notifications\r\n  WHERE expires_at IS NOT NULL\r\n  AND expires_at < NOW();\r\nEND;\r\n"
  },
  {
    "function_name": "cleanup_old_podcast_chunks",
    "arguments": "retention_days integer",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  DELETE FROM podcast_chunks WHERE created_at < now() - (retention_days || ' days')::interval;\r\nEND;\r\n"
  },
  {
    "function_name": "cleanup_podcast_cohosts",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  IF NEW.is_live = false AND OLD.is_live = true THEN\r\n    DELETE FROM podcast_cohosts WHERE podcast_id = NEW.id;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "create_social_user_profile",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  -- Skip creation until the email is verified\n  IF NEW.email_confirmed_at IS NULL THEN\n    RETURN NULL;  -- No social user entry yet\n  END IF;\n\n  INSERT INTO public.social_users (id, username, display_name)\n  VALUES (\n    NEW.id,\n    CONCAT('user_', substr(md5(random()::text), 0, 8)),\n    CONCAT('User ', substr(md5(random()::text), 0, 8))\n  );\n\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "expire_old_podcast_invites",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE public.podcast_invites\r\n  SET status = 'expired'\r\n  WHERE status = 'pending'\r\n  AND expires_at < NOW();\r\nEND;\r\n"
  },
  {
    "function_name": "generate_referral_code",
    "arguments": "",
    "return_type": "text",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n  result TEXT := '';\n  i INTEGER;\nBEGIN\n  FOR i IN 1..6 LOOP\n    result := result || substr(chars, floor(random() * length(chars) + 1)::integer, 1);\n  END LOOP;\n  RETURN result;\nEND;\n"
  },
  {
    "function_name": "generate_unique_username",
    "arguments": "p_email text",
    "return_type": "text",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    base     text := regexp_replace(split_part(p_email, '@', 1), '[^a-zA-Z0-9]', '_', 'g');\n    suffix   int  := 0;\n    candidate text;\nBEGIN\n    LOOP\n        candidate := base || CASE WHEN suffix = 0 THEN '' ELSE '_' || suffix::text END;\n\n        -- If the candidate is not already taken, exit the loop\n        PERFORM 1 FROM public.social_users WHERE username = candidate;\n        EXIT WHEN NOT FOUND;\n\n        suffix := suffix + 1;\n    END LOOP;\n\n    RETURN candidate;\nEND;\n"
  },
  {
    "function_name": "get_due_flashcards",
    "arguments": "p_user_id uuid, p_limit integer",
    "return_type": "TABLE(id uuid, front text, back text, category text, difficulty text, hint text, review_count integer, ease_factor numeric)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        f.id,\n        f.front,\n        f.back,\n        f.category,\n        f.difficulty,\n        f.hint,\n        f.review_count,\n        f.ease_factor\n    FROM public.flashcards f\n    WHERE f.user_id = p_user_id\n    AND (f.next_review_at IS NULL OR f.next_review_at <= NOW())\n    ORDER BY f.next_review_at NULLS FIRST, f.created_at\n    LIMIT p_limit;\nEND;\n"
  },
  {
    "function_name": "get_learning_velocity",
    "arguments": "p_user_id uuid, p_weeks integer",
    "return_type": "TABLE(week text, items bigint)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH weeks AS (\r\n    SELECT generate_series(\r\n      CURRENT_DATE - (p_weeks * 7 - 1), \r\n      CURRENT_DATE, \r\n      '1 week'::interval\r\n    )::date as week_start\r\n  )\r\n  SELECT \r\n    'W' || row_number() OVER (ORDER BY weeks.week_start) as week,\r\n    COUNT(n.id) as items\r\n  FROM weeks\r\n  LEFT JOIN notes n ON n.user_id = p_user_id \r\n    AND n.created_at >= weeks.week_start \r\n    AND n.created_at < weeks.week_start + '7 days'::interval\r\n  GROUP BY weeks.week_start\r\n  ORDER BY weeks.week_start;\r\nEND;\r\n"
  },
  {
    "function_name": "get_or_create_group_chat_session",
    "arguments": "p_group_id uuid",
    "return_type": "uuid",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_session_id UUID;\r\nBEGIN\r\n  -- Try to find existing session\r\n  SELECT id INTO v_session_id\r\n  FROM social_chat_sessions\r\n  WHERE chat_type = 'group' AND group_id = p_group_id\r\n  LIMIT 1;\r\n  \r\n  -- Create if doesn't exist\r\n  IF v_session_id IS NULL THEN\r\n    INSERT INTO social_chat_sessions (chat_type, group_id)\r\n    VALUES ('group', p_group_id)\r\n    RETURNING id INTO v_session_id;\r\n  END IF;\r\n  \r\n  RETURN v_session_id;\r\nEND;\r\n"
  },
  {
    "function_name": "get_schema_tables",
    "arguments": "",
    "return_type": "TABLE(table_name text, table_type text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    table_name::text,\r\n    table_type::text\r\n  FROM information_schema.tables\r\n  WHERE table_schema = 'public'\r\n    AND table_type = 'BASE TABLE'\r\n  ORDER BY table_name;\r\n"
  },
  {
    "function_name": "get_session_unread_count",
    "arguments": "p_session_id uuid, p_user_id uuid",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT COUNT(*)::INTEGER\r\n        FROM social_chat_messages\r\n        WHERE session_id = p_session_id\r\n        AND sender_id != p_user_id\r\n        AND is_read = FALSE\r\n    );\r\nEND;\r\n"
  },
  {
    "function_name": "get_suggested_users",
    "arguments": "p_user_id uuid, p_exclude_ids uuid[], p_limit integer, p_offset integer",
    "return_type": "TABLE(id uuid, username text, display_name text, avatar_url text, bio text, interests text[], followers_count integer, following_count integer, posts_count integer, is_verified boolean, last_active timestamp with time zone, created_at timestamp with time zone, recommendation_score numeric)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\ndeclare\r\n  thirty_days_ago timestamptz := now() - interval '30 days';\r\n  v_user_interests text[] := '{}';\r\nbegin\r\n  select coalesce(su2.interests, '{}') into v_user_interests\r\n  from social_users su2\r\n  where su2.id = p_user_id;\r\n\r\n  return query\r\n  select\r\n    su.id,\r\n    su.username,\r\n    su.display_name,\r\n    su.avatar_url,\r\n    su.bio,\r\n    su.interests,\r\n    su.followers_count,\r\n    su.following_count,\r\n    su.posts_count,\r\n    su.is_verified,\r\n    su.last_active,\r\n    su.created_at,\r\n\r\n    (\r\n      -- common interests (10 pts each)\r\n      (select coalesce(sum(1),0)\r\n       from unnest(coalesce(su.interests, '{}')) as i\r\n       where i = any(v_user_interests)\r\n      ) * 10\r\n\r\n      -- recent activity (5 pts)\r\n      + (case when su.last_active > thirty_days_ago then 5 else 0 end)\r\n\r\n      -- follower bonus (max 5 pts)\r\n      + least(coalesce(su.followers_count,0) / 100.0, 5)\r\n\r\n      -- post bonus (max 3 pts)\r\n      + least(coalesce(su.posts_count,0) / 10.0, 3)\r\n\r\n      -- profile completeness (max 3 pts)\r\n      + (case when su.avatar_url is not null then 1 else 0 end)\r\n      + (case when su.bio is not null and su.bio <> 'New to the community!' then 1 else 0 end)\r\n      + (case when coalesce(array_length(su.interests,1),0) > 0 then 1 else 0 end)\r\n\r\n      -- verified bonus (2 pts)\r\n      + (case when su.is_verified then 2 else 0 end)\r\n    )::numeric as recommendation_score\r\n\r\n  from social_users su\r\n  where su.id <> ALL(p_exclude_ids)\r\n  order by recommendation_score desc\r\n  limit p_limit\r\n  offset p_offset;\r\nend;\r\n"
  },
  {
    "function_name": "get_table_columns",
    "arguments": "table_name text",
    "return_type": "TABLE(name text, type text, nullable boolean, is_primary_key boolean, is_foreign_key boolean, default_value text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    c.column_name::text AS name,\r\n    c.data_type::text AS type,\r\n    (c.is_nullable = 'YES')::boolean AS nullable,\r\n    (EXISTS (\r\n      SELECT 1 FROM information_schema.key_column_usage kcu\r\n      JOIN information_schema.table_constraints tc \r\n        ON kcu.constraint_name = tc.constraint_name\r\n      WHERE tc.constraint_type = 'PRIMARY KEY'\r\n        AND kcu.table_name = c.table_name\r\n        AND kcu.column_name = c.column_name\r\n    ))::boolean AS is_primary_key,\r\n    (EXISTS (\r\n      SELECT 1 FROM information_schema.key_column_usage kcu\r\n      JOIN information_schema.table_constraints tc \r\n        ON kcu.constraint_name = tc.constraint_name\r\n      WHERE tc.constraint_type = 'FOREIGN KEY'\r\n        AND kcu.table_name = c.table_name\r\n        AND kcu.column_name = c.column_name\r\n    ))::boolean AS is_foreign_key,\r\n    c.column_default::text AS default_value\r\n  FROM information_schema.columns c\r\n  WHERE c.table_schema = 'public'\r\n    AND c.table_name = $1\r\n  ORDER BY c.ordinal_position;\r\n"
  },
  {
    "function_name": "get_table_policies",
    "arguments": "table_name text",
    "return_type": "TABLE(name text, operation text, using_expression text, check_expression text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    policyname::text AS name,\r\n    cmd::text AS operation,\r\n    qual::text AS using_expression,\r\n    with_check::text AS check_expression\r\n  FROM pg_policies\r\n  WHERE schemaname = 'public'\r\n    AND tablename = $1;\r\n"
  },
  {
    "function_name": "get_table_relationships",
    "arguments": "table_name text",
    "return_type": "TABLE(from_table text, to_table text, from_column text, to_column text, constraint_name text)",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  SELECT \r\n    tc.table_name::text AS from_table,\r\n    ccu.table_name::text AS to_table,\r\n    kcu.column_name::text AS from_column,\r\n    ccu.column_name::text AS to_column,\r\n    tc.constraint_name::text\r\n  FROM information_schema.table_constraints tc\r\n  JOIN information_schema.key_column_usage kcu\r\n    ON tc.constraint_name = kcu.constraint_name\r\n    AND tc.table_schema = kcu.table_schema\r\n  JOIN information_schema.constraint_column_usage ccu\r\n    ON ccu.constraint_name = tc.constraint_name\r\n    AND ccu.table_schema = tc.table_schema\r\n  WHERE tc.constraint_type = 'FOREIGN KEY'\r\n    AND tc.table_schema = 'public'\r\n    AND tc.table_name = $1;\r\n"
  },
  {
    "function_name": "get_user_activity_history",
    "arguments": "p_user_id uuid, p_start_date timestamp with time zone, p_interval text",
    "return_type": "TABLE(period timestamp with time zone, notes_count bigint, recordings_count bigint, documents_count bigint, quizzes_count bigint, messages_count bigint)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH periods AS (\r\n    SELECT generate_series(\r\n      date_trunc(p_interval, p_start_date),\r\n      date_trunc(p_interval, NOW()),\r\n      ('1 ' || p_interval)::INTERVAL\r\n    ) AS period_start\r\n  ),\r\n  notes_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM notes\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  recordings_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM class_recordings\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  documents_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM documents\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  quizzes_agg AS (\r\n    SELECT date_trunc(p_interval, created_at) AS period, COUNT(*) as cnt\r\n    FROM quiz_attempts\r\n    WHERE user_id = p_user_id AND created_at >= p_start_date\r\n    GROUP BY 1\r\n  ),\r\n  messages_agg AS (\r\n     -- Join with chat_sessions to check ownership if needed, but chat_messages usually has user_id\r\n     -- Schema says chat_messages.user_id references profiles(id) which references auth.users(id)\r\n    SELECT date_trunc(p_interval, timestamp) AS period, COUNT(*) as cnt\r\n    FROM chat_messages\r\n    WHERE user_id = p_user_id AND timestamp >= p_start_date\r\n    GROUP BY 1\r\n  )\r\n  SELECT\r\n    p.period_start,\r\n    COALESCE(n.cnt, 0),\r\n    COALESCE(r.cnt, 0),\r\n    COALESCE(d.cnt, 0),\r\n    COALESCE(q.cnt, 0),\r\n    COALESCE(m.cnt, 0)\r\n  FROM periods p\r\n  LEFT JOIN notes_agg n ON p.period_start = n.period\r\n  LEFT JOIN recordings_agg r ON p.period_start = r.period\r\n  LEFT JOIN documents_agg d ON p.period_start = d.period\r\n  LEFT JOIN quizzes_agg q ON p.period_start = q.period\r\n  LEFT JOIN messages_agg m ON p.period_start = m.period\r\n  ORDER BY p.period_start;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_activity_stats",
    "arguments": "p_user_id uuid, p_days integer",
    "return_type": "TABLE(date text, notes bigint, recordings bigint, documents bigint, messages bigint, total bigint)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH days AS (\r\n    SELECT generate_series(\r\n      date_trunc('day', now() - interval '1 day' * (p_days - 1)),\r\n      date_trunc('day', now()),\r\n      '1 day'::interval\r\n    ) as day\r\n  )\r\n  SELECT\r\n    to_char(d.day, 'Mon DD') as date,\r\n    COALESCE(n.cnt, 0) as notes,\r\n    COALESCE(r.cnt, 0) as recordings,\r\n    COALESCE(doc.cnt, 0) as documents,\r\n    COALESCE(m.cnt, 0) as messages,\r\n    COALESCE(n.cnt, 0) + COALESCE(r.cnt, 0) + COALESCE(doc.cnt, 0) + COALESCE(m.cnt, 0) as total\r\n  FROM days d\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', created_at) as day, count(*) as cnt\r\n    FROM notes WHERE user_id = p_user_id\r\n    AND created_at >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) n ON n.day = d.day\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', created_at) as day, count(*) as cnt\r\n    FROM class_recordings WHERE user_id = p_user_id\r\n    AND created_at >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) r ON r.day = d.day\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', created_at) as day, count(*) as cnt\r\n    FROM documents WHERE user_id = p_user_id\r\n    AND created_at >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) doc ON doc.day = d.day\r\n  LEFT JOIN (\r\n    SELECT date_trunc('day', timestamp) as day, count(*) as cnt\r\n    FROM chat_messages WHERE user_id = p_user_id\r\n    AND timestamp >= now() - interval '1 day' * p_days\r\n    GROUP BY 1\r\n  ) m ON m.day = d.day\r\n  ORDER BY d.day;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_stats_with_achievements",
    "arguments": "user_uuid uuid",
    "return_type": "TABLE(user_id uuid, total_xp integer, level integer, current_streak integer, longest_streak integer, total_quizzes_attempted integer, total_quizzes_completed integer, average_score numeric, total_study_time_seconds integer, badges_earned text[], last_activity_date timestamp with time zone, achievements_count bigint)",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    us.*,\r\n    COUNT(a.id) as achievements_count\r\n  FROM user_stats us\r\n  LEFT JOIN achievements a ON a.user_id = us.user_id\r\n  WHERE us.user_id = user_uuid\r\n  GROUP BY us.user_id, us.total_xp, us.level, us.current_streak, us.longest_streak,\r\n           us.total_quizzes_attempted, us.total_quizzes_completed, us.average_score,\r\n           us.total_study_time_seconds, us.badges_earned, us.last_activity_date;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_streak",
    "arguments": "p_user_id uuid",
    "return_type": "TABLE(current_streak integer, max_streak integer)",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_current_streak INTEGER := 0;\r\n  v_max_streak INTEGER := 0;\r\n  v_dates DATE[];\r\nBEGIN\r\n  -- Get all unique dates with activity from various tables\r\n  -- We prioritize 'created_at' or 'timestamp' columns\r\n  \r\n  SELECT ARRAY(\r\n    SELECT DISTINCT date_trunc('day', activity_time)::DATE\r\n    FROM (\r\n      -- Notes\r\n      SELECT created_at as activity_time FROM notes WHERE user_id = p_user_id\r\n      UNION ALL\r\n      -- Class Recordings\r\n      SELECT created_at as activity_time FROM class_recordings WHERE user_id = p_user_id\r\n      UNION ALL\r\n      -- Documents\r\n      SELECT created_at as activity_time FROM documents WHERE user_id = p_user_id\r\n      UNION ALL\r\n      -- Chat Messages\r\n      SELECT timestamp as activity_time FROM chat_messages WHERE user_id = p_user_id\r\n    ) all_activities\r\n    WHERE activity_time IS NOT NULL\r\n    ORDER BY date_trunc('day', activity_time)::DATE DESC\r\n  ) INTO v_dates;\r\n\r\n  -- Calculate streaks\r\n  IF array_length(v_dates, 1) > 0 THEN\r\n    -- Debug: Check if the most recent activity is today or yesterday\r\n    -- If the latest activity is older than yesterday, streak is 0\r\n    IF v_dates[1] >= (CURRENT_DATE - INTERVAL '1 day') THEN\r\n        v_current_streak := 1;\r\n        \r\n        -- Iterate backwards to find consecutive days\r\n        IF array_length(v_dates, 1) > 1 THEN\r\n            FOR i IN 1..array_length(v_dates, 1) - 1 LOOP\r\n                -- Difference between dates should be 1 day\r\n                IF (v_dates[i] - v_dates[i+1]) = 1 THEN\r\n                    v_current_streak := v_current_streak + 1;\r\n                ELSE\r\n                    -- If the gap is more than 1 day, the streak is broken\r\n                     EXIT;\r\n                END IF;\r\n            END LOOP;\r\n        END IF;\r\n    ELSE\r\n        -- Streak broke if no activity today or yesterday\r\n        v_current_streak := 0;\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Calculate historical max streak\r\n  DECLARE\r\n    temp_streak INTEGER := 0;\r\n    temp_max INTEGER := 0;\r\n  BEGIN\r\n    IF array_length(v_dates, 1) > 0 THEN\r\n        temp_streak := 1;\r\n        temp_max := 1;\r\n        IF array_length(v_dates, 1) > 1 THEN\r\n            FOR i IN 1..array_length(v_dates, 1) - 1 LOOP\r\n                IF (v_dates[i] - v_dates[i+1]) = 1 THEN\r\n                    temp_streak := temp_streak + 1;\r\n                ELSE\r\n                    if temp_streak > temp_max THEN\r\n                        temp_max := temp_streak;\r\n                    END IF;\r\n                    temp_streak := 1;\r\n                END IF;\r\n            END LOOP;\r\n            -- Check last streak\r\n            if temp_streak > temp_max THEN\r\n                temp_max := temp_streak;\r\n            END IF;\r\n        END IF;\r\n        v_max_streak := temp_max;\r\n    END IF;\r\n  END;\r\n\r\n  RETURN QUERY SELECT v_current_streak, v_max_streak;\r\nEND;\r\n"
  },
  {
    "function_name": "get_user_unread_count",
    "arguments": "p_user_id uuid",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT COUNT(*)::INTEGER\r\n        FROM social_chat_messages m\r\n        JOIN social_chat_sessions s ON m.session_id = s.id\r\n        WHERE (s.user_id1 = p_user_id OR s.user_id2 = p_user_id)\r\n        AND m.sender_id != p_user_id\r\n        AND m.is_read = FALSE\r\n    );\r\nEND;\r\n"
  },
  {
    "function_name": "get_xp_for_level",
    "arguments": "level_num integer",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN (level_num - 1) * (level_num - 1) * 100;\r\nEND;\r\n"
  },
  {
    "function_name": "guard_log_admin_activity",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  v_role text;\n  v_user_id uuid;\n  v_admin_role text;\n  v_admin_id uuid;\nBEGIN\n  -- try role from JWT\n  BEGIN\n    v_role := auth.jwt() ->> 'role';\n  EXCEPTION WHEN undefined_function THEN\n    v_role := NULL;\n  END;\n\n  -- if role absent or not one of the admin roles, try DB lookup\n  IF v_role IS NULL OR v_role NOT IN ('admin','super_admin','moderator') THEN\n    BEGIN\n      v_user_id := (SELECT auth.uid());\n    EXCEPTION WHEN undefined_function THEN\n      v_user_id := NULL;\n    END;\n\n    IF v_user_id IS NOT NULL THEN\n      SELECT role, id INTO v_admin_role, v_admin_id FROM public.admin_users WHERE user_id = v_user_id LIMIT 1;\n      IF v_admin_role IS NOT NULL AND v_admin_role IN ('admin','super_admin','moderator') THEN\n        -- call existing logging procedure if present, using admin id\n        PERFORM public.log_admin_activity();\n        RETURN COALESCE(NEW, OLD);\n      END IF;\n    END IF;\n\n    -- no admin role found; do nothing\n    RETURN COALESCE(NEW, OLD);\n  ELSE\n    -- JWT indicates admin role; proceed to log using existing procedure\n    PERFORM public.log_admin_activity();\n    RETURN COALESCE(NEW, OLD);\n  END IF;\nEND;\n"
  },
  {
    "function_name": "handle_new_comment_notification",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    post_owner_id UUID;\n    preview_text TEXT;\nBEGIN\n    -- Get post owner (use author_id)\n    SELECT author_id INTO post_owner_id\n    FROM public.social_posts\n    WHERE id = NEW.post_id;\n\n    -- Ignore if commenting on own post\n    IF post_owner_id IS NOT NULL AND post_owner_id != NEW.author_id THEN\n        preview_text := substring(NEW.content from 1 for 50);\n        IF length(NEW.content) > 50 THEN\n            preview_text := preview_text || '...';\n        END IF;\n\n        -- 1. Insert into general 'notifications' (Push)\n        INSERT INTO public.notifications (user_id, type, title, message, data, read)\n        VALUES (\n            post_owner_id,\n            'social_comment',\n            'New Comment',\n            'Someone commented: ' || preview_text,\n            jsonb_build_object('post_id', NEW.post_id, 'comment_id', NEW.id),\n            false\n        );\n\n        -- 2. Insert into 'social_notifications' (Frontend) â€” include title and message\n        INSERT INTO public.social_notifications (user_id, actor_id, type, title, message, post_id, is_read)\n        VALUES (\n            post_owner_id,\n            NEW.author_id,\n            'comment',\n            'New Comment',\n            'Someone commented: ' || preview_text,\n            NEW.post_id,\n            false\n        );\n\n    END IF;\n\n    RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_like_notification",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    post_owner_id UUID;\n    comment_owner_id UUID;\n    notification_body TEXT;\nBEGIN\n    -- CASE 1: Liking a POST\n    IF NEW.post_id IS NOT NULL THEN\n        SELECT author_id INTO post_owner_id FROM public.social_posts WHERE id = NEW.post_id;\n\n        -- social_likes table uses 'user_id' (liker)\n        IF post_owner_id IS NOT NULL AND post_owner_id != NEW.user_id THEN\n            INSERT INTO public.notifications (user_id, type, title, message, data, read)\n            VALUES (post_owner_id, 'social_like', 'New Like', 'Someone liked your post', jsonb_build_object('post_id', NEW.post_id), false);\n\n            INSERT INTO public.social_notifications (user_id, actor_id, type, title, message, post_id, is_read)\n            VALUES (post_owner_id, NEW.user_id, 'like', 'New Like', 'Someone liked your post', NEW.post_id, false);\n        END IF;\n\n    -- CASE 2: Liking a COMMENT\n    ELSIF NEW.comment_id IS NOT NULL THEN\n        SELECT author_id, post_id INTO comment_owner_id, post_owner_id FROM public.social_comments WHERE id = NEW.comment_id;\n\n        IF comment_owner_id IS NOT NULL AND comment_owner_id != NEW.user_id THEN\n            INSERT INTO public.notifications (user_id, type, title, message, data, read)\n            VALUES (comment_owner_id, 'social_like', 'New Like', 'Someone liked your comment', jsonb_build_object('post_id', post_owner_id, 'comment_id', NEW.comment_id), false);\n\n            INSERT INTO public.social_notifications (user_id, actor_id, type, title, message, post_id, is_read)\n            VALUES (comment_owner_id, NEW.user_id, 'like', 'Comment Liked', 'Someone liked your comment', post_owner_id, false);\n        END IF;\n    END IF;\n\n    RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_user",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  BEGIN\n    PERFORM public.handle_new_user_inner(row_to_json(NEW)::jsonb);\n  EXCEPTION WHEN OTHERS THEN\n    INSERT INTO public._trigger_debug_log(event, details)\n    VALUES ('handle_new_user_exception', jsonb_build_object('err', SQLERRM, 'user', row_to_json(NEW)));\n    RAISE; -- rethrow so caller sees error\n  END;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_user_debug",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  BEGIN\n    PERFORM public.handle_new_user();\n  EXCEPTION WHEN OTHERS THEN\n    INSERT INTO public._trigger_debug_log(event, details)\n    VALUES ('handle_new_user_error', jsonb_build_object('err', SQLERRM, 'stack', NULL));\n    RAISE; -- re-raise to surface the error\n  END;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "handle_new_user_inner",
    "arguments": "p_new jsonb",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  display_name TEXT;\n  user_email TEXT;\nBEGIN\n  user_email := p_new->>'email';\n\n  IF p_new->'raw_user_meta_data' IS NOT NULL AND (p_new->'raw_user_meta_data'->>'full_name') IS NOT NULL THEN\n    display_name := p_new->'raw_user_meta_data'->>'full_name';\n  ELSIF p_new->'raw_user_meta_data' IS NOT NULL AND (p_new->'raw_user_meta_data'->>'name') IS NOT NULL THEN\n    display_name := p_new->'raw_user_meta_data'->>'name';\n  ELSE\n    display_name := SPLIT_PART(user_email, '@', 1);\n  END IF;\n\n  INSERT INTO public.social_users (id, display_name, username, email, avatar_url, bio, is_public, created_at, updated_at)\n  VALUES (\n    (p_new->>'id')::uuid,\n    display_name,\n    LOWER(REGEXP_REPLACE(SPLIT_PART(user_email, '@', 1), '[^a-zA-Z0-9]', '', 'g')) || '_' || SUBSTRING((p_new->>'id'), 1, 6),\n    user_email,\n    COALESCE(p_new->'raw_user_meta_data'->>'avatar_url', p_new->'raw_user_meta_data'->>'picture', NULL),\n    'New to StuddyHub! ðŸ‘‹',\n    true,\n    NOW(),\n    NOW()\n  )\n  ON CONFLICT (id) DO NOTHING;\n\n  INSERT INTO public.profiles (id, full_name, avatar_url, created_at, updated_at)\n  VALUES (\n    (p_new->>'id')::uuid,\n    display_name,\n    COALESCE(p_new->'raw_user_meta_data'->>'avatar_url', p_new->'raw_user_meta_data'->>'picture', NULL),\n    NOW(),\n    NOW()\n  )\n  ON CONFLICT (id) DO UPDATE SET\n    full_name = COALESCE(EXCLUDED.full_name, profiles.full_name),\n    avatar_url = COALESCE(EXCLUDED.avatar_url, profiles.avatar_url),\n    updated_at = NOW();\nEND;\n"
  },
  {
    "function_name": "handle_user_update",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  -- Update social_users with latest metadata if profile exists\r\n  UPDATE public.social_users\r\n  SET\r\n    avatar_url = COALESCE(\r\n      NEW.raw_user_meta_data->>'avatar_url',\r\n      NEW.raw_user_meta_data->>'picture',\r\n      avatar_url\r\n    ),\r\n    updated_at = NOW()\r\n  WHERE id = NEW.id;\r\n\r\n  -- Update profiles table\r\n  UPDATE public.profiles\r\n  SET\r\n    avatar_url = COALESCE(\r\n      NEW.raw_user_meta_data->>'avatar_url',\r\n      NEW.raw_user_meta_data->>'picture',\r\n      avatar_url\r\n    ),\r\n    updated_at = NOW()\r\n  WHERE id = NEW.id;\r\n\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "increment_podcast_listen_count",
    "arguments": "podcast_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE public.ai_podcasts\r\n  SET listen_count = listen_count + 1\r\n  WHERE id = podcast_id;\r\nEND;\r\n"
  },
  {
    "function_name": "increment_podcast_share_count",
    "arguments": "podcast_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE public.ai_podcasts\r\n  SET share_count = share_count + 1,\r\n      updated_at = NOW()\r\n  WHERE id = podcast_id;\r\nEND;\r\n"
  },
  {
    "function_name": "is_podcast_cohost",
    "arguments": "p_podcast_id uuid, p_user_id uuid",
    "return_type": "boolean",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM podcast_cohosts \r\n    WHERE podcast_id = p_podcast_id \r\n    AND user_id = p_user_id \r\n    AND is_active = true\r\n  );\r\nEND;\r\n"
  },
  {
    "function_name": "log_admin_activity",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_actor uuid; -- will hold admin_users.id\r\n  v_actor_user uuid; -- will hold auth.uid() if available\r\n  v_record_id text;\r\n  v_old jsonb;\r\n  v_new jsonb;\r\n  v_payload text;\r\nBEGIN\r\n  -- Try to get actor user id from auth.uid(); if not available, leave NULL\r\n  BEGIN\r\n    v_actor_user := (SELECT auth.uid());\r\n  EXCEPTION WHEN undefined_function THEN\r\n    v_actor_user := NULL;\r\n  END;\r\n\r\n  -- Map to admin_users.id if possible\r\n  IF v_actor_user IS NOT NULL THEN\r\n    SELECT id INTO v_actor FROM public.admin_users WHERE user_id = v_actor_user LIMIT 1;\r\n  ELSE\r\n    v_actor := NULL;\r\n  END IF;\r\n\r\n  IF (TG_OP = 'INSERT') THEN\r\n    v_new := to_jsonb(NEW);\r\n    v_old := NULL;\r\n    v_record_id := NULL;\r\n    BEGIN\r\n      IF (SELECT column_name FROM information_schema.columns WHERE table_schema=TG_TABLE_SCHEMA AND table_name=TG_TABLE_NAME AND column_name='id' LIMIT 1) IS NOT NULL THEN\r\n        v_record_id := NEW.id::text;\r\n      END IF;\r\n    EXCEPTION WHEN others THEN\r\n      v_record_id := NULL;\r\n    END;\r\n  ELSIF (TG_OP = 'UPDATE') THEN\r\n    v_old := to_jsonb(OLD);\r\n    v_new := to_jsonb(NEW);\r\n    BEGIN\r\n      v_record_id := NEW.id::text;\r\n    EXCEPTION WHEN others THEN\r\n      v_record_id := NULL;\r\n    END;\r\n  ELSIF (TG_OP = 'DELETE') THEN\r\n    v_old := to_jsonb(OLD);\r\n    v_new := NULL;\r\n    BEGIN\r\n      v_record_id := OLD.id::text;\r\n    EXCEPTION WHEN others THEN\r\n      v_record_id := NULL;\r\n    END;\r\n  END IF;\r\n\r\n  v_payload := jsonb_build_object(\r\n    'operation', TG_OP,\r\n    'table', TG_TABLE_NAME,\r\n    'record_id', v_record_id,\r\n    'old', v_old,\r\n    'new', v_new\r\n  )::text;\r\n\r\n  -- Insert admin_activity_logs with resolved admin_users.id (v_actor). admin_id is nullable.\r\n  INSERT INTO public.admin_activity_logs(admin_id, action)\r\n  VALUES (v_actor, v_payload);\r\n\r\n  IF (TG_OP = 'DELETE') THEN\r\n    RETURN OLD;\r\n  ELSE\r\n    RETURN NEW;\r\n  END IF;\r\nEND;\r\n"
  },
  {
    "function_name": "log_admin_activity",
    "arguments": "_action text, _target_type text, _target_id uuid, _details jsonb",
    "return_type": "uuid",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "search_path=public",
    "source_code": "\nDECLARE\n    _admin_id UUID;\n    _log_id UUID;\nBEGIN\n    -- Get admin_id from current user\n    SELECT id INTO _admin_id FROM public.admin_users WHERE user_id = auth.uid();\n    \n    IF _admin_id IS NULL THEN\n        RAISE EXCEPTION 'User is not an admin';\n    END IF;\n    \n    -- Insert log entry\n    INSERT INTO public.admin_activity_logs (admin_id, action, target_type, target_id, details)\n    VALUES (_admin_id, _action, _target_type, _target_id, _details)\n    RETURNING id INTO _log_id;\n    \n    RETURN _log_id;\nEND;\n"
  },
  {
    "function_name": "log_schema_query",
    "arguments": "p_user_id uuid, p_operation text, p_table_name text, p_query_intent jsonb, p_success boolean, p_error_message text, p_execution_time_ms integer",
    "return_type": "void",
    "language": "sql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\n  INSERT INTO schema_agent_audit (\r\n    user_id, operation, table_name, query_intent,\r\n    success, error_message, execution_time_ms\r\n  ) VALUES (\r\n    p_user_id, p_operation, p_table_name, p_query_intent,\r\n    p_success, p_error_message, p_execution_time_ms\r\n  );\r\n"
  },
  {
    "function_name": "mark_all_notifications_read",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE notifications\r\n  SET read = TRUE, read_at = NOW()\r\n  WHERE user_id = auth.uid() AND read = FALSE;\r\nEND;\r\n"
  },
  {
    "function_name": "mark_notification_read",
    "arguments": "notification_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE notifications\r\n  SET read = TRUE, read_at = NOW()\r\n  WHERE id = notification_id AND user_id = auth.uid();\r\nEND;\r\n"
  },
  {
    "function_name": "mark_session_messages_read",
    "arguments": "p_session_id uuid, p_user_id uuid",
    "return_type": "integer",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  v_count integer := 0;\nBEGIN\n  INSERT INTO public.social_chat_message_reads (message_id, user_id, read_at)\n  SELECT m.id, p_user_id, NOW()\n  FROM public.social_chat_messages m\n  WHERE m.session_id = p_session_id\n    AND m.sender_id != p_user_id\n  ON CONFLICT (message_id, user_id) DO UPDATE SET read_at = NOW();\n\n  GET DIAGNOSTICS v_count = ROW_COUNT;\n  RETURN v_count;\nEND;\n"
  },
  {
    "function_name": "notify_chat_message",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  session_rec RECORD;\r\n  sender_username text;\r\n  recipient_id uuid;\r\nBEGIN\r\n  -- Get chat session details\r\n  SELECT chat_type, user_id1, user_id2, group_id\r\n  INTO session_rec\r\n  FROM social_chat_sessions\r\n  WHERE id = NEW.session_id;\r\n  \r\n  -- Get sender's username\r\n  SELECT username INTO sender_username\r\n  FROM social_users\r\n  WHERE id = NEW.sender_id;\r\n  \r\n  -- Only notify for P2P messages (group messages handled separately)\r\n  IF session_rec.chat_type = 'p2p' THEN\r\n    -- Determine recipient\r\n    IF session_rec.user_id1 = NEW.sender_id THEN\r\n      recipient_id := session_rec.user_id2;\r\n    ELSE\r\n      recipient_id := session_rec.user_id1;\r\n    END IF;\r\n    \r\n    -- Create notification\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      recipient_id,\r\n      'ai_message',  -- Using ai_message type for chat messages\r\n      'New Message',\r\n      sender_username || ': ' || LEFT(NEW.content, 50) || CASE WHEN LENGTH(NEW.content) > 50 THEN '...' ELSE '' END,\r\n      jsonb_build_object(\r\n        'actor_id', NEW.sender_id,\r\n        'actor_username', sender_username,\r\n        'message_id', NEW.id,\r\n        'session_id', NEW.session_id,\r\n        'chat_type', 'p2p'\r\n      ),\r\n      now()\r\n    );\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_comment_like",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  comment_author_id uuid;\r\n  related_post_id uuid;\r\nBEGIN\r\n  -- Only proceed if this is a comment like\r\n  IF NEW.comment_id IS NOT NULL THEN\r\n    -- FIX: Select author_id instead of user_id from social_comments\r\n    SELECT author_id, post_id INTO comment_author_id, related_post_id\r\n    FROM public.social_comments\r\n    WHERE id = NEW.comment_id;\r\n\r\n    -- Only notify if liker is not the comment author\r\n    IF comment_author_id IS NOT NULL AND comment_author_id != NEW.user_id THEN\r\n      INSERT INTO public.social_notifications (\r\n        user_id,\r\n        actor_id,\r\n        type,\r\n        title,\r\n        message,\r\n        post_id,\r\n        data\r\n      ) VALUES (\r\n        comment_author_id,\r\n        NEW.user_id,\r\n        'like', -- or 'comment_like' if your enum supports it\r\n        'Comment Liked',\r\n        'Someone liked your comment',\r\n        related_post_id,\r\n        jsonb_build_object('comment_id', NEW.comment_id)\r\n      );\r\n    END IF;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_comment_mention",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  mentioned_user RECORD;\r\n  author_username text;\r\nBEGIN\r\n  -- Get author's username\r\n  SELECT username INTO author_username\r\n  FROM social_users\r\n  WHERE id = NEW.author_id;\r\n  \r\n  -- Find all @mentions in the content\r\n  FOR mentioned_user IN\r\n    SELECT su.id, su.username\r\n    FROM social_users su\r\n    WHERE NEW.content ~* ('@' || su.username || '([^a-zA-Z0-9_]|$)')\r\n      AND su.id != NEW.author_id  -- Don't notify self-mentions\r\n  LOOP\r\n    -- Create notification for each mentioned user\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      mentioned_user.id,\r\n      'social_mention',\r\n      'You were mentioned',\r\n      author_username || ' mentioned you in a comment',\r\n      jsonb_build_object(\r\n        'actor_id', NEW.author_id,\r\n        'actor_username', author_username,\r\n        'comment_id', NEW.id,\r\n        'post_id', NEW.post_id,\r\n        'mentioned_username', mentioned_user.username\r\n      ),\r\n      now()\r\n    );\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_group_invite",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  group_name text;\r\n  inviter_username text;\r\nBEGIN\r\n  -- Only notify for pending invites\r\n  IF NEW.status != 'pending' THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Get group name\r\n  SELECT name INTO group_name\r\n  FROM social_groups\r\n  WHERE id = NEW.group_id;\r\n  \r\n  -- Get inviter (group creator or admin - simplified to just use group creator)\r\n  SELECT su.username INTO inviter_username\r\n  FROM social_groups sg\r\n  JOIN social_users su ON sg.created_by = su.id\r\n  WHERE sg.id = NEW.group_id;\r\n  \r\n  -- Create notification\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    data,\r\n    created_at\r\n  ) VALUES (\r\n    NEW.user_id,\r\n    'social_like',  -- Using social_like for group invites\r\n    'Group Invitation',\r\n    'You were invited to join ' || group_name,\r\n    jsonb_build_object(\r\n      'group_id', NEW.group_id,\r\n      'group_name', group_name,\r\n      'membership_id', NEW.id\r\n    ),\r\n    now()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_group_message",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  session_rec RECORD;\r\n  sender_username text;\r\n  member_rec RECORD;\r\n  group_name text;\r\nBEGIN\r\n  -- Get chat session details\r\n  SELECT chat_type, group_id\r\n  INTO session_rec\r\n  FROM social_chat_sessions\r\n  WHERE id = NEW.session_id;\r\n  \r\n  -- Only process group messages\r\n  IF session_rec.chat_type != 'group' OR session_rec.group_id IS NULL THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Get sender's username and group name\r\n  SELECT username INTO sender_username\r\n  FROM social_users\r\n  WHERE id = NEW.sender_id;\r\n  \r\n  SELECT name INTO group_name\r\n  FROM social_groups\r\n  WHERE id = session_rec.group_id;\r\n  \r\n  -- Notify all group members except sender\r\n  FOR member_rec IN\r\n    SELECT user_id\r\n    FROM social_group_members\r\n    WHERE group_id = session_rec.group_id\r\n      AND user_id != NEW.sender_id\r\n      AND status = 'active'\r\n  LOOP\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      member_rec.user_id,\r\n      'ai_message',\r\n      group_name,\r\n      sender_username || ': ' || LEFT(NEW.content, 50) || CASE WHEN LENGTH(NEW.content) > 50 THEN '...' ELSE '' END,\r\n      jsonb_build_object(\r\n        'actor_id', NEW.sender_id,\r\n        'actor_username', sender_username,\r\n        'message_id', NEW.id,\r\n        'session_id', NEW.session_id,\r\n        'group_id', session_rec.group_id,\r\n        'group_name', group_name,\r\n        'chat_type', 'group'\r\n      ),\r\n      now()\r\n    );\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_new_follower",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  follower_username text;\r\nBEGIN\r\n  -- Get follower's username\r\n  SELECT username INTO follower_username\r\n  FROM social_users\r\n  WHERE id = NEW.follower_id;\r\n  \r\n  -- Create notification\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    data,\r\n    created_at\r\n  ) VALUES (\r\n    NEW.following_id,\r\n    'social_like',  -- Using social_like as there's no social_follow type\r\n    'New Follower',\r\n    follower_username || ' started following you',\r\n    jsonb_build_object(\r\n      'actor_id', NEW.follower_id,\r\n      'actor_username', follower_username,\r\n      'follow_id', NEW.id\r\n    ),\r\n    now()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_post_comment",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  post_author_id uuid;\nBEGIN\n  -- Get post author using 'author_id'\n  SELECT author_id INTO post_author_id\n  FROM public.social_posts\n  WHERE id = NEW.post_id;\n\n  -- Only notify if the commenter is not the post author\n  IF post_author_id IS NOT NULL AND post_author_id != NEW.author_id THEN\n    INSERT INTO public.social_notifications (\n      user_id,\n      actor_id,\n      type,\n      title,\n      message,\n      post_id,\n      data\n    ) VALUES (\n      post_author_id,\n      NEW.author_id,\n      'comment',\n      'New Comment',\n      'Someone commented on your post',\n      NEW.post_id,\n      jsonb_build_object('comment_id', NEW.id)\n    );\n  END IF;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "notify_post_like",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  post_author_id uuid;\nBEGIN\n  -- Only proceed if this is a post like (not a comment like)\n  IF NEW.post_id IS NOT NULL THEN\n    SELECT author_id INTO post_author_id\n    FROM public.social_posts\n    WHERE id = NEW.post_id;\n\n    -- Only notify if the liker is not the post author\n    IF post_author_id IS NOT NULL AND post_author_id != NEW.user_id THEN\n      INSERT INTO public.social_notifications (\n        user_id,\n        actor_id,\n        type,\n        title,\n        message,\n        post_id,\n        data\n      ) VALUES (\n        post_author_id,\n        NEW.user_id,\n        'like',\n        'New Like',\n        'Someone liked your post',\n        NEW.post_id,\n        jsonb_build_object('type', 'post_like')\n      );\n    END IF;\n  END IF;\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "notify_post_mention",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  mentioned_user RECORD;\r\n  author_username text;\r\n  mention_pattern text;\r\nBEGIN\r\n  -- Get author's username\r\n  SELECT username INTO author_username\r\n  FROM social_users\r\n  WHERE id = NEW.author_id;\r\n  \r\n  -- Find all @mentions in the content\r\n  FOR mentioned_user IN\r\n    SELECT su.id, su.username\r\n    FROM social_users su\r\n    WHERE NEW.content ~* ('@' || su.username || '([^a-zA-Z0-9_]|$)')\r\n      AND su.id != NEW.author_id  -- Don't notify self-mentions\r\n  LOOP\r\n    -- Create notification for each mentioned user\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      data,\r\n      created_at\r\n    ) VALUES (\r\n      mentioned_user.id,\r\n      'social_mention',\r\n      'You were mentioned',\r\n      author_username || ' mentioned you in a post',\r\n      jsonb_build_object(\r\n        'actor_id', NEW.author_id,\r\n        'actor_username', author_username,\r\n        'post_id', NEW.id,\r\n        'mentioned_username', mentioned_user.username\r\n      ),\r\n      now()\r\n    );\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "notify_post_share",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  original_author_id uuid;\r\n  sharer_username text;\r\nBEGIN\r\n  -- Get original post author\r\n  SELECT author_id INTO original_author_id\r\n  FROM social_posts\r\n  WHERE id = NEW.original_post_id;\r\n  \r\n  -- Don't notify if sharing own post\r\n  IF original_author_id = NEW.user_id THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Get sharer's username\r\n  SELECT username INTO sharer_username\r\n  FROM social_users\r\n  WHERE id = NEW.user_id;\r\n  \r\n  -- Create notification\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    data,\r\n    created_at\r\n  ) VALUES (\r\n    original_author_id,\r\n    'social_like',  -- Using social_like for shares\r\n    'Post Shared',\r\n    sharer_username || ' shared your post',\r\n    jsonb_build_object(\r\n      'actor_id', NEW.user_id,\r\n      'actor_username', sharer_username,\r\n      'post_id', NEW.original_post_id,\r\n      'share_id', NEW.id\r\n    ),\r\n    now()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "process_referral_reward",
    "arguments": "p_referee_id uuid, p_referral_code text",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n  v_referrer_id UUID;\n  v_referral_id UUID;\n  v_current_sub RECORD;\nBEGIN\n  -- Find referrer by code\n  SELECT id INTO v_referrer_id FROM public.profiles WHERE referral_code = p_referral_code;\n  \n  IF v_referrer_id IS NULL THEN\n    RETURN jsonb_build_object('success', false, 'error', 'Invalid referral code');\n  END IF;\n  \n  IF v_referrer_id = p_referee_id THEN\n    RETURN jsonb_build_object('success', false, 'error', 'Cannot refer yourself');\n  END IF;\n  \n  -- Check if already referred\n  IF EXISTS(SELECT 1 FROM public.referrals WHERE referee_id = p_referee_id) THEN\n    RETURN jsonb_build_object('success', false, 'error', 'Already referred');\n  END IF;\n  \n  -- Create referral record\n  INSERT INTO public.referrals (referrer_id, referee_id, status)\n  VALUES (v_referrer_id, p_referee_id, 'completed')\n  RETURNING id INTO v_referral_id;\n  \n  -- Grant +10 AI credits to referee\n  UPDATE public.profiles\n  SET bonus_ai_credits = COALESCE(bonus_ai_credits, 0) + 10\n  WHERE id = p_referee_id;\n  \n  -- Grant +3 days Scholar to referrer\n  SELECT * INTO v_current_sub FROM public.subscriptions WHERE user_id = v_referrer_id;\n  \n  IF v_current_sub IS NULL THEN\n    -- Create new subscription with 3 days Scholar\n    INSERT INTO public.subscriptions (user_id, plan_type, status, current_period_end)\n    VALUES (v_referrer_id, 'scholar', 'active', now() + interval '3 days');\n  ELSE\n    -- Extend existing subscription\n    UPDATE public.subscriptions\n    SET \n      plan_type = CASE WHEN plan_type = 'free' THEN 'scholar' ELSE plan_type END,\n      current_period_end = GREATEST(COALESCE(current_period_end, now()), now()) + interval '3 days',\n      status = 'active'\n    WHERE user_id = v_referrer_id;\n  END IF;\n  \n  -- Update referrer stats\n  UPDATE public.profiles\n  SET referral_count = COALESCE(referral_count, 0) + 1\n  WHERE id = v_referrer_id;\n  \n  -- Mark referral as reward granted\n  UPDATE public.referrals SET reward_granted = true WHERE id = v_referral_id;\n  \n  RETURN jsonb_build_object('success', true, 'referrer_id', v_referrer_id);\nEND;\n"
  },
  {
    "function_name": "review_flashcard",
    "arguments": "p_flashcard_id uuid, p_user_id uuid, p_quality integer",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\nDECLARE\n    v_ease_factor NUMERIC;\n    v_interval_days INTEGER;\n    v_review_count INTEGER;\nBEGIN\n    -- Get current values\n    SELECT ease_factor, interval_days, review_count\n    INTO v_ease_factor, v_interval_days, v_review_count\n    FROM public.flashcards\n    WHERE id = p_flashcard_id AND user_id = p_user_id;\n\n    -- Update ease factor (SuperMemo 2 algorithm)\n    v_ease_factor := v_ease_factor + (0.1 - (5 - p_quality) * (0.08 + (5 - p_quality) * 0.02));\n    \n    IF v_ease_factor < 1.3 THEN\n        v_ease_factor := 1.3;\n    END IF;\n\n    -- Calculate new interval\n    IF p_quality < 3 THEN\n        v_interval_days := 1; -- Reset if quality is too low\n    ELSE\n        IF v_review_count = 0 THEN\n            v_interval_days := 1;\n        ELSIF v_review_count = 1 THEN\n            v_interval_days := 6;\n        ELSE\n            v_interval_days := ROUND(v_interval_days * v_ease_factor)::INTEGER;\n        END IF;\n    END IF;\n\n    -- Update the flashcard\n    UPDATE public.flashcards\n    SET \n        review_count = review_count + 1,\n        last_reviewed_at = NOW(),\n        next_review_at = NOW() + (v_interval_days || ' days')::INTERVAL,\n        ease_factor = v_ease_factor,\n        interval_days = v_interval_days,\n        updated_at = NOW()\n    WHERE id = p_flashcard_id AND user_id = p_user_id;\nEND;\n"
  },
  {
    "function_name": "send_push_notification",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  subscription_rec RECORD;\r\n  preferences_rec RECORD;\r\n  payload jsonb;\r\n  request_id bigint;\r\nBEGIN\r\n  -- Get user preferences\r\n  SELECT * INTO preferences_rec\r\n  FROM notification_preferences\r\n  WHERE user_id = NEW.user_id;\r\n  \r\n  -- Check if push notifications are enabled\r\n  IF preferences_rec IS NULL OR preferences_rec.push_notifications = false THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Check notification type preference\r\n  IF NEW.type = 'schedule_reminder' AND preferences_rec.schedule_reminders = false THEN\r\n    RETURN NEW;\r\n  ELSIF NEW.type = 'quiz_due' AND preferences_rec.quiz_reminders = false THEN\r\n    RETURN NEW;\r\n  ELSIF NEW.type IN ('social_like', 'social_comment', 'social_mention') AND preferences_rec.social_notifications = false THEN\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  -- Check quiet hours\r\n  IF preferences_rec.quiet_hours_enabled THEN\r\n    IF (CURRENT_TIME >= preferences_rec.quiet_hours_start OR CURRENT_TIME < preferences_rec.quiet_hours_end) THEN\r\n      RETURN NEW;\r\n    END IF;\r\n  END IF;\r\n  \r\n  -- Get all active subscriptions for this user\r\n  FOR subscription_rec IN\r\n    SELECT * FROM notification_subscriptions\r\n    WHERE user_id = NEW.user_id\r\n  LOOP\r\n    -- Build the push notification payload\r\n    payload := jsonb_build_object(\r\n      'title', NEW.title,\r\n      'body', NEW.message,\r\n      'icon', '/icon-192.png',\r\n      'badge', '/badge-72.png',\r\n      'tag', NEW.type,\r\n      'data', jsonb_build_object(\r\n        'id', NEW.id,\r\n        'type', NEW.type,\r\n        'data', COALESCE(NEW.data, '{}'::jsonb)\r\n      ),\r\n      'requireInteraction', (NEW.type IN ('schedule_reminder', 'quiz_due')),\r\n      'timestamp', EXTRACT(EPOCH FROM NOW()) * 1000\r\n    );\r\n    \r\n    -- Send push notification using web-push protocol\r\n    -- This is a simplified version - in production, use the send-notification edge function\r\n    -- or configure a Database Webhook\r\n    \r\n    -- For now, we'll use pg_net to make an async HTTP request to our edge function\r\n    SELECT net.http_post(\r\n      url := current_setting('app.supabase_url', true) || '/functions/v1/send-notification',\r\n      headers := jsonb_build_object(\r\n        'Content-Type', 'application/json',\r\n        'Authorization', 'Bearer ' || current_setting('app.supabase_service_role_key', true)\r\n      ),\r\n      body := jsonb_build_object(\r\n        'user_id', NEW.user_id,\r\n        'type', NEW.type,\r\n        'title', NEW.title,\r\n        'message', NEW.message,\r\n        'data', NEW.data,\r\n        'save_to_db', false\r\n      )\r\n    ) INTO request_id;\r\n    \r\n    -- Exit after first request to avoid duplicate notifications\r\n    EXIT;\r\n  END LOOP;\r\n  \r\n  RETURN NEW;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    -- Log error but don't fail the insert\r\n    RAISE WARNING 'Failed to send push notification for notification %: %', NEW.id, SQLERRM;\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "sync_profile_to_social",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  UPDATE public.social_users\n  SET email        = NEW.email,\n      avatar_url   = NEW.avatar_url,\n      display_name = NEW.full_name,   -- map profile.full_name â†’ social.display_name\n      username     = NEW.username,    -- map profile.username â†’ social.username\n      updated_at   = now()\n  WHERE id = NEW.id\n    AND (email        IS DISTINCT FROM NEW.email\n      OR avatar_url   IS DISTINCT FROM NEW.avatar_url\n      OR display_name IS DISTINCT FROM NEW.full_name\n      OR username     IS DISTINCT FROM NEW.username);\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "sync_social_to_profile",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n  UPDATE public.profiles\n  SET email       = NEW.email,\n      avatar_url  = NEW.avatar_url,\n      full_name   = NEW.display_name,   -- map display name â†’ profile.full_name\n      username    = NEW.username,       -- map username â†’ profile.username\n      updated_at  = now()\n  WHERE id = NEW.id\n    AND (email       IS DISTINCT FROM NEW.email\n      OR avatar_url  IS DISTINCT FROM NEW.avatar_url\n      OR full_name   IS DISTINCT FROM NEW.display_name\n      OR username    IS DISTINCT FROM NEW.username);\n  RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "update_chat_message_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_chat_session_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  -- Only update if session_id is not null\r\n  IF NEW.session_id IS NOT NULL THEN\r\n    UPDATE social_chat_sessions\r\n    SET last_message_at = NEW.created_at,\r\n        updated_at = NOW()\r\n    WHERE id = NEW.session_id;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_context_size",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    IF NEW.context_summary IS NOT NULL THEN\r\n        NEW.context_size_bytes = LENGTH(NEW.context_summary);\r\n    ELSE\r\n        NEW.context_size_bytes = 0;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_flashcard_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
  },
  {
    "function_name": "update_goal_progress",
    "arguments": "goal_id uuid, new_progress integer",
    "return_type": "void",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  UPDATE user_learning_goals \r\n  SET \r\n    progress = new_progress,\r\n    is_completed = (new_progress = 100),\r\n    updated_at = NOW()\r\n  WHERE id = goal_id;\r\nEND;\r\n"
  },
  {
    "function_name": "update_session_last_message",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    UPDATE social_chat_sessions\r\n    SET \r\n        last_message_at = NEW.created_at,\r\n        updated_at = NOW()\r\n    WHERE id = NEW.session_id;\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security": "SECURITY INVOKER",
    "config_settings": "(none)",
    "source_code": "\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "function_name": "validate_and_execute_query",
    "arguments": "p_user_id uuid, p_operation text, p_table_name text, p_columns jsonb, p_conditions jsonb, p_data jsonb, p_limit integer",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security": "SECURITY DEFINER",
    "config_settings": "(none)",
    "source_code": "\r\nDECLARE\r\n  v_result jsonb;\r\n  v_query text;\r\n  v_has_user_id boolean;\r\nBEGIN\r\n  -- Check if table exists\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM information_schema.tables\r\n    WHERE table_schema = 'public' AND table_name = p_table_name\r\n  ) THEN\r\n    RAISE EXCEPTION 'Table % does not exist', p_table_name;\r\n  END IF;\r\n\r\n  -- Check if table has user_id column\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM information_schema.columns\r\n    WHERE table_schema = 'public'\r\n      AND table_name = p_table_name\r\n      AND column_name = 'user_id'\r\n  ) INTO v_has_user_id;\r\n\r\n  -- For tables with user_id, enforce user isolation\r\n  IF v_has_user_id THEN\r\n    -- Inject user_id condition if not present\r\n    IF p_conditions IS NULL THEN\r\n      p_conditions := jsonb_build_array(\r\n        jsonb_build_object(\r\n          'column', 'user_id',\r\n          'operator', 'eq',\r\n          'value', p_user_id::text\r\n        )\r\n      );\r\n    ELSIF NOT EXISTS (\r\n      SELECT 1 FROM jsonb_array_elements(p_conditions) AS condition\r\n      WHERE condition->>'column' = 'user_id'\r\n    ) THEN\r\n      p_conditions := p_conditions || jsonb_build_array(\r\n        jsonb_build_object(\r\n          'column', 'user_id',\r\n          'operator', 'eq',\r\n          'value', p_user_id::text\r\n        )\r\n      );\r\n    END IF;\r\n\r\n    -- For INSERT, inject user_id into data\r\n    IF p_operation = 'INSERT' AND p_data IS NOT NULL THEN\r\n      p_data := p_data || jsonb_build_object('user_id', p_user_id);\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Execute operation based on type\r\n  CASE p_operation\r\n    WHEN 'SELECT' THEN\r\n      -- Build SELECT query\r\n      v_query := format('SELECT * FROM %I', p_table_name);\r\n      -- Add WHERE conditions\r\n      IF p_conditions IS NOT NULL THEN\r\n        v_query := v_query || ' WHERE ' || build_where_clause(p_conditions);\r\n      END IF;\r\n      -- Add LIMIT\r\n      IF p_limit IS NOT NULL THEN\r\n        v_query := v_query || format(' LIMIT %s', p_limit);\r\n      END IF;\r\n      \r\n      EXECUTE v_query INTO v_result;\r\n      \r\n    WHEN 'INSERT' THEN\r\n      -- Validate required columns\r\n      -- Execute INSERT\r\n      v_query := format(\r\n        'INSERT INTO %I (%s) VALUES (%s) RETURNING *',\r\n        p_table_name,\r\n        (SELECT string_agg(key, ', ') FROM jsonb_object_keys(p_data) AS key),\r\n        (SELECT string_agg(quote_literal(value), ', ') FROM jsonb_each_text(p_data) AS value)\r\n      );\r\n      \r\n      EXECUTE v_query INTO v_result;\r\n      \r\n    WHEN 'UPDATE' THEN\r\n      -- Execute UPDATE with conditions\r\n      v_query := format('UPDATE %I SET ', p_table_name);\r\n      v_query := v_query || (\r\n        SELECT string_agg(format('%I = %L', key, value), ', ')\r\n        FROM jsonb_each_text(p_data)\r\n      );\r\n      IF p_conditions IS NOT NULL THEN\r\n        v_query := v_query || ' WHERE ' || build_where_clause(p_conditions);\r\n      END IF;\r\n      v_query := v_query || ' RETURNING *';\r\n      \r\n      EXECUTE v_query INTO v_result;\r\n      \r\n    WHEN 'DELETE' THEN\r\n      -- Execute DELETE with conditions\r\n      v_query := format('DELETE FROM %I', p_table_name);\r\n      IF p_conditions IS NOT NULL THEN\r\n        v_query := v_query || ' WHERE ' || build_where_clause(p_conditions);\r\n      END IF;\r\n      \r\n      EXECUTE v_query;\r\n      v_result := jsonb_build_object('deleted', true);\r\n      \r\n    ELSE\r\n      RAISE EXCEPTION 'Unsupported operation: %', p_operation;\r\n  END CASE;\r\n\r\n  RETURN v_result;\r\nEND;\r\n"
  }
][
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "52c4a6d5-c875-488e-90fa-74e94ba53c5a",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416996461000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "4c94443b-508f-42ac-93d8-b965d2fb2883",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416995431000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "b0ea27fc-0a0a-47d9-ad15-df22d49e8e58",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416989115000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "92516b6e-531f-492d-8ed1-7106a90b4500",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416988587000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "57395c16-d25a-468d-b0a6-e97a5e8637cb",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416982971000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "e7ecaf29-b2cc-46bb-9f76-6b69d70d37c0",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416974319000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "2f79b77c-973c-4ab0-b622-3e6445bb8857",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416974319000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "65b84763-b350-4aa6-aafd-491ca2636ce5",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416972634000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "1d864f26-2b0f-4f85-80df-3a8ec97eee4c",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416972634000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "614ef95c-5f74-4cdc-82b1-ce3294cf29cb",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416972234000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "18300ef1-fe57-4e5c-bb30-71a2688cc01d",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416971687000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling autovacuum task",
    "hint": null,
    "id": "9d4b9f12-e7ac-467e-a53d-1c30c7324c38",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416962142000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "process 72937 acquired RowExclusiveLock on relation 17107 of database 5 after 1629.619 ms",
    "hint": null,
    "id": "58ac53f5-2769-42b5-aafb-83e21e6607ee",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416962142000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "process 72935 acquired RowExclusiveLock on relation 17107 of database 5 after 1693.800 ms",
    "hint": null,
    "id": "a71dd8f3-36ec-4ded-9107-47b7b60ae6ca",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416962142000
  },
  {
    "detail": "Process holding the lock: 73049. Wait queue: 72935, 72937.",
    "error_severity": "LOG",
    "event_message": "process 72937 still waiting for RowExclusiveLock on relation 17107 of database 5 after 1000.078 ms",
    "hint": null,
    "id": "a77a8ae8-b7ac-44e3-9d62-38b4ae5e7a96",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416961520000
  },
  {
    "detail": "Process holding the lock: 73049. Wait queue: 72935, 72937.",
    "error_severity": "LOG",
    "event_message": "process 72935 still waiting for RowExclusiveLock on relation 17107 of database 5 after 1000.075 ms",
    "hint": null,
    "id": "d9a8551a-e9da-4dbf-8a2c-e390fcbfd5e9",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416961467000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "6c90416f-d9d1-4c5a-861b-1ca1a4cd8876",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416961117000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "bf448771-b285-4a29-ad16-6d70dfaefe6d",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416959474000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "5209a33a-c0eb-4383-8bc8-3b803756d324",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416958093000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "c39d3cc0-aa80-4369-835d-85a879832bb5",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416957892000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=supabase_admin database=postgres application_name=postgres_exporter",
    "hint": null,
    "id": "10da5daf-57f8-43c7-9823-0d2b47d3c650",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416957452000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"supabase_admin\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "c7463c53-3c93-492d-a34d-f68481d70ef8",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416957452000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "invalid input syntax for type uuid: \"\"",
    "hint": null,
    "id": "0219c671-abb6-4dc4-8dce-f13414e0067b",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416956569000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "6ba15c8b-939d-4b61-9112-f4a8b9077e4b",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416956247000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "39d39654-5da5-4ff8-9432-e35e01f107df",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416956195000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "4d2d3275-6ed8-40e3-b910-5a59690a7470",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416955888000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "4f25dad4-85f1-4012-88fc-242e12e87939",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416950423000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "duplicate key value violates unique constraint \"profiles_pkey\"",
    "hint": null,
    "id": "6860db18-3db5-4e08-a8e4-afdc62cf2db7",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416948552000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "cron job 3 completed: 1 row",
    "hint": null,
    "id": "c9bb9042-0be9-497a-9e5f-8b83d5852fc9",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416945260000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "cron job 1 completed: 1 row",
    "hint": null,
    "id": "1e163066-ab1c-40c0-ba32-75f3213ef19d",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416945258000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "24d4d9d8-acda-4099-a7ce-e378e6f39e76",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416944533000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=supabase_auth_admin database=postgres",
    "hint": null,
    "id": "c022ac85-dadf-4453-ae06-98420d9c8372",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416944227000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"supabase_auth_admin\" method=trust (/etc/postgresql/pg_hba.conf:84)",
    "hint": null,
    "id": "23e7ba28-f9b8-4d91-a859-1db4ed9bdb0d",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416944227000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"supabase_auth_admin\" method=trust (/etc/postgresql/pg_hba.conf:84)",
    "hint": null,
    "id": "a47929d7-16e2-498b-ae35-20481e0f355a",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416943681000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=supabase_auth_admin database=postgres",
    "hint": null,
    "id": "593d7375-c6f7-471c-a11d-1b80f22b51c1",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416943681000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=postgres database=postgres application_name=pg_cron SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)",
    "hint": null,
    "id": "ea068f29-cf0f-4fc6-b78b-db9dc6ba7d2f",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416943294000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"postgres\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "ca4e4971-9418-4b17-a446-a78b380d96d9",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416943294000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"postgres\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "d0d7e090-d1d8-4e40-96ab-a09a85535bda",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416943287000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=postgres database=postgres application_name=pg_cron SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)",
    "hint": null,
    "id": "0e8ae9ad-e611-4d2e-8441-c52ff3ae4919",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416943287000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection received: host=127.0.0.1 port=43929",
    "hint": null,
    "id": "50216094-db20-4d0b-b625-91f168e9cad7",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416942971000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection received: host=127.0.0.1 port=43913",
    "hint": null,
    "id": "678915ed-22fb-4b1e-8039-7e24c89a3836",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416942929000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "cac59e02-3bb2-4c20-b076-0614c275dea7",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416941180000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "952dbf2a-6f12-4e85-b452-2ee143f49891",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416940914000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection received: host=127.0.0.1 port=41265",
    "hint": null,
    "id": "e14a1f3e-33b2-4d3b-a75c-e503e3b030c4",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416938928000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "e3f3efdb-f84e-4249-9f77-68751b54e6ce",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416938170000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "25bb178a-2e0b-46d1-932e-1225f72a7b73",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416937655000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "process 72957 acquired ShareLock on transaction 1040450 after 7910.692 ms",
    "hint": null,
    "id": "485e4c5b-2b84-4b88-878b-4f2bea98eded",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416936986000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "4355c808-2c00-4ea0-a318-2d25bf3e8648",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416936915000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "79eee6d2-1ed0-402d-aeca-48fbcae1c881",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416936850000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "370bf006-b595-40cf-a2d5-d80635a15f26",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416934656000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "23e04761-e4da-45d0-a7ee-3fe048d109df",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416932775000
  },
  {
    "detail": "Process holding the lock: 72994. Wait queue: 72957.",
    "error_severity": "LOG",
    "event_message": "process 72957 still waiting for ShareLock on transaction 1040450 after 1000.064 ms",
    "hint": null,
    "id": "ff951517-19aa-4de8-957c-6f9507d305f9",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416930062000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "duplicate key value violates unique constraint \"profiles_pkey\"",
    "hint": null,
    "id": "e99d2fdd-d366-48fa-b793-21bb995d3628",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416927512000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "duplicate key value violates unique constraint \"profiles_pkey\"",
    "hint": null,
    "id": "1f266645-a197-4605-a505-e301f6622d2d",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416926386000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "0fa5906b-d472-4cda-96d1-34406a483394",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416925698000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "0e7e9de5-2350-4731-a640-42819fb50a6e",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416923620000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "63cd0437-dfe6-4a74-98c6-1db44bfbcf6d",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416923603000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "0b582b7f-66f8-4348-9b93-49fa6af6d2a0",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416923444000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "21af804b-b6fc-425c-8370-6bb7d4e1d018",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416922394000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "b6a5281c-d126-4d8e-aebc-937013f3b7fd",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416915919000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "13b55be2-cb16-46f8-a957-877e2e2ec849",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416914269000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "39521efd-aeef-4f7e-841d-dc3017c3a993",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416913565000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "894119f4-45ee-4926-913d-ca0896ca5397",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416912866000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "b13cb6ec-1da7-435c-9dd1-6b419437c8e0",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416912573000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "68d229e9-9cd4-4afe-89da-fc8bbc2d12f1",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416912557000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "2de486d7-0315-4d96-978c-56b85b655a46",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416911093000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "process 72937 acquired RowExclusiveLock on relation 17107 of database 5 after 3589.386 ms",
    "hint": null,
    "id": "bbfab3d1-f958-48f2-8c64-a07b94632d28",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416908918000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "process 72935 acquired RowExclusiveLock on relation 17107 of database 5 after 3619.092 ms",
    "hint": null,
    "id": "55a41e92-054c-4360-9811-d9b337dccf5c",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416908918000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling autovacuum task",
    "hint": null,
    "id": "cc05de28-3a7c-4ff6-967c-a1a67641b00f",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416908895000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=authenticator database=postgres application_name=postgrest SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)",
    "hint": null,
    "id": "2b954223-c7cc-4575-b2aa-9a1e7233ffd9",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416906381000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"authenticator\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "dd80a888-4cd6-45e5-8a0f-d50df6c19c32",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416906381000
  },
  {
    "detail": "Process holding the lock: 73014. Wait queue: 72935, 72937.",
    "error_severity": "LOG",
    "event_message": "process 72937 still waiting for RowExclusiveLock on relation 17107 of database 5 after 1000.064 ms",
    "hint": null,
    "id": "d107f7f5-91d9-4d53-80c8-eca97e0f2025",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416906337000
  },
  {
    "detail": "Process holding the lock: 73014. Wait queue: 72935, 72937.",
    "error_severity": "LOG",
    "event_message": "process 72935 still waiting for RowExclusiveLock on relation 17107 of database 5 after 1000.065 ms",
    "hint": null,
    "id": "c4969961-b201-4f75-9f81-f281951251bb",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416906304000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection received: host=::1 port=46227",
    "hint": null,
    "id": "3784afc4-7c4e-4502-8cac-22eb50942d17",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416906291000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "110dccfb-aae7-4774-9996-043e2124539e",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416904937000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "fcd77a60-a2bf-4587-afdb-76a17b8e5c2b",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416903680000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=authenticator database=postgres application_name=postgrest SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)",
    "hint": null,
    "id": "d596c9f4-8178-446f-8e53-3008ba58eb59",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416902630000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"authenticator\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "74fd18b4-0118-4b8b-adae-623011faf1f2",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416902627000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "f7c3bc3b-cdc4-42f8-832d-d5ef9a8a1be0",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416902211000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "a8126eab-73bb-4207-bf9f-968b455b8eee",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416902106000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "e16aa9e9-9ea4-48fc-865a-bbfd42e24896",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416902024000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "c2572aed-2624-4d4e-b781-1ad2a4ac2a16",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416898467000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "e8e2505c-ad86-44d2-a617-0546ef6c5e98",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416897578000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "9352d087-a5c7-4b08-ab95-6cd61bf02b03",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416897523000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "10f51068-bd49-436a-a67f-d89e854a8029",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416896283000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=supabase_admin database=postgres application_name=postgres_exporter",
    "hint": null,
    "id": "05d3ad36-00c0-4e7e-9328-68f48ce2c702",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416894199000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"supabase_admin\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "73e3c9f4-d22f-404c-b2fc-ca2f31d91941",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416894199000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection received: host=::1 port=8637",
    "hint": null,
    "id": "6656abc6-323c-46e0-b8b2-da7ea69dbd3c",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416894142000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "cron job 3 completed: 1 row",
    "hint": null,
    "id": "d60d01c1-3c54-4fab-b711-f1a2b96a070c",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416888594000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "cron job 1 completed: 1 row",
    "hint": null,
    "id": "66f6b62c-1754-401d-9a9f-a326c28b6c04",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416888592000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"postgres\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "f66da533-06ce-4cf2-b000-e2e71b027733",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416887583000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=postgres database=postgres application_name=pg_cron SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)",
    "hint": null,
    "id": "666e1245-fb5e-477b-924f-bdb35043be55",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416887583000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authenticated: user=\"postgres\" method=trust (/etc/postgresql/pg_hba.conf:85)",
    "hint": null,
    "id": "363d422c-a432-48e4-ab61-247ca2df9440",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416887583000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection authorized: user=postgres database=postgres application_name=pg_cron SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)",
    "hint": null,
    "id": "95851448-cad6-4a73-ab9d-354282d4b720",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416887583000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "365a79fd-3e5c-4c11-99b2-b014d3cb777f",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416887230000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "2f68d6be-c23c-45ef-8302-4ccc46b051ab",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416886604000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "7f5b2cdb-cae4-48fc-8475-5fb2f4810501",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416886584000
  },
  {
    "detail": null,
    "error_severity": "ERROR",
    "event_message": "canceling statement due to statement timeout",
    "hint": null,
    "id": "276dbb22-0d4c-4a38-91c9-7609a5a89bed",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416886566000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "cron job 1 starting: select",
    "hint": null,
    "id": "e6518518-87f5-4050-8947-070753e2eb51",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416885210000
  },
  {
    "detail": null,
    "error_severity": "LOG",
    "event_message": "connection received: host=127.0.0.1 port=49187",
    "hint": null,
    "id": "14313be8-994f-48a8-a2c7-9e0761e77aa3",
    "identifier": "kegsrvnywshxyucgjxml",
    "timestamp": 1770416883608000
  }
]
